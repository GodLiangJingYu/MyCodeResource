<!doctype html>
<html lang="zh-CN">
 <head> 
  <meta charset="utf-8"> 
  <link rel="canonical" href="https://blog.csdn.net/qq_62325622/article/details/134852570"> 
  <meta http-equiv="content-type" content="text/html; charset=utf-8"> 
  <meta name="renderer" content="webkit"> 
  <meta name="force-rendering" content="webkit"> 
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"> 
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"> 
  <meta name="report" content="{&quot;pid&quot;: &quot;blog&quot;, &quot;spm&quot;:&quot;1001.2101&quot;}"> 
  <meta name="referrer" content="always"> 
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <link rel="alternate" media="handheld" href="#"> 
  <meta name="shenma-site-verification" content="5a59773ab8077d4a62bf469ab966a63b_1497598848"> 
  <meta name="applicable-device" content="pc"> 
  <link href="https://g.csdnimg.cn/static/logo/favicon32.ico" rel="shortcut icon" type="image/x-icon"> 
  <title>史上最全的操作系统复习笔记（基于王道和自己整理）-CSDN博客</title>  
  <meta name="keywords" content="操作系统复习"> 
  <meta name="csdn-baidu-search" content="{&quot;autorun&quot;:true,&quot;install&quot;:true,&quot;keyword&quot;:&quot;操作系统复习&quot;}"> 
  <meta name="description" content="文章浏览阅读3.4w次，点赞400次，收藏1.4k次。本博客是整理了王道操作系统的视频，视频结合自己的理解整理的资料，后续会有更多的每一章的关键的习题的整理，和后续的考研真题~_操作系统复习"> 
  <link rel="stylesheet" type="text/css" href="https://csdnimg.cn/release/blogv2/dist/pc/css/detail_enter-af0ead44cd.min.css">  
  <link rel="stylesheet" type="text/css" href="https://csdnimg.cn/release/blogv2/dist/pc/themesSkin/skin-number/skin-number-2c93789924.min.css">    
  <meta name="toolbar" content="{&quot;type&quot;:&quot;0&quot;,&quot;fixModel&quot;:&quot;1&quot;}">    
  <link rel="stylesheet" type="text/css" href="https://csdnimg.cn/public/sandalstrap/1.4/css/sandalstrap.min.css"> 
  <style>
        .MathJax, .MathJax_Message, .MathJax_Preview{
            display: none
        }
    </style>      
 	<style>
	main div.blog-content-box pre {
		max-height: 100%;
		overflow-y: hidden;
	}
	</style>
 </head>  
 <body class="nodata  " style=""> 
  <div id="toolbarBox" style="min-height: 48px;"></div>    
  <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/pc/css/blog_code-01256533b5.min.css"> 
  <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/chart-3456820cac.css"> 
  <link rel="stylesheet" href="https://g.csdnimg.cn/lib/swiper/6.0.4/css/swiper.css">   
  <div class="main_father clearfix d-flex justify-content-center mainfather-concision" style="height:100%;"> 
   <div class="container clearfix container-concision" id="mainBox">  
    <main>  
     <div class="blog-content-box"> 
      <div class="article-header-box"> 
       <div class="article-header"> 
        <div class="article-title-box"> 
         <h1 class="title-article" id="articleContentId">史上最全的操作系统复习笔记（基于王道和自己整理）</h1> 
        </div> 
        <div class="article-info-box"> 
         <div class="article-bar-top"> 
          <img class="article-type-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png" alt=""> 
          <div class="bar-content"> 
           <a class="follow-nickName " href="https://blog.csdn.net/qq_62325622" target="_blank" rel="noopener" title="用草书谱写兰亭序">用草书谱写兰亭序</a> 
           <img class="article-time-img article-heard-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newUpTime2.png" alt=""> 
           <span class="time">已于&nbsp;2023-12-10 00:54:33&nbsp;修改</span> 
           <div class="read-count-box"> 
            <img class="article-read-img article-heard-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png" alt=""> 
            <span class="read-count">阅读量3.4w</span> 
            <a id="blog_detail_zk_collection" class="un-collection" data-report-click="{&quot;mod&quot;:&quot;popu_823&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4232&quot;,&quot;ab&quot;:&quot;new&quot;}"> <img class="article-collect-img article-heard-img un-collect-status isdefault" style="display:inline-block" src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png" alt=""> <img class="article-collect-img article-heard-img collect-status isactive" style="display:none" src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollectionActive2.png" alt=""> <span class="name">收藏</span> <span class="get-collection"> 1.4k </span> </a> 
            <div class="read-count-box is-like" data-type="top"> 
             <img class="article-read-img article-heard-img" style="display:none" id="is-like-imgactive-new" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Active.png" alt=""> 
             <img class="article-read-img article-heard-img" style="display:block" id="is-like-img-new" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png" alt=""> 
             <span class="read-count" id="blog-digg-num">点赞数 400 </span> 
            </div> 
           </div> 
          </div> 
         </div> 
         <div class="blog-tags-box"> 
          <div class="tags-box artic-tag-box"> 
           <span class="label">分类专栏：</span> 
           <a class="tag-link" href="https://blog.csdn.net/qq_62325622/category_12522101.html" target="_blank" rel="noopener">操作系统</a> 
           <span class="label">文章标签：</span> 
           <a rel="noopener" data-report-query="spm=1001.2101.3001.4223" data-report-click="{&quot;mod&quot;:&quot;popu_626&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4223&quot;,&quot;strategy&quot;:&quot;windows&quot;,&quot;ab&quot;:&quot;new&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;windows\&quot;}&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_626&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4223&quot;,&quot;strategy&quot;:&quot;windows&quot;,&quot;ab&quot;:&quot;new&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;windows\&quot;}&quot;}" class="tag-link" href="https://so.csdn.net/so/search/s.do?q=windows&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" target="_blank">windows</a> 
           <a rel="noopener" data-report-query="spm=1001.2101.3001.4223" data-report-click="{&quot;mod&quot;:&quot;popu_626&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4223&quot;,&quot;strategy&quot;:&quot;linux&quot;,&quot;ab&quot;:&quot;new&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;linux\&quot;}&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_626&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4223&quot;,&quot;strategy&quot;:&quot;linux&quot;,&quot;ab&quot;:&quot;new&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;linux\&quot;}&quot;}" class="tag-link" href="https://so.csdn.net/so/search/s.do?q=linux&amp;t=all&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=&amp;from_tracking_code=tag_word&amp;from_code=app_blog_art" target="_blank">linux</a> 
          </div> 
         </div> 
         <div class="up-time">
          <span>于&nbsp;2023-12-07 19:08:27&nbsp;首次发布</span>
         </div> 
         <div class="slide-content-box"> 
          <div class="article-copyright"> 
           <div class="creativecommons">
             版权声明：本文为博主原创文章，遵循
            <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。 
           </div> 
           <div class="article-source-link">
             本文链接：
            <a href="https://blog.csdn.net/qq_62325622/article/details/134852570" target="_blank">https://blog.csdn.net/qq_62325622/article/details/134852570</a> 
           </div> 
          </div> 
         </div> 
         <div class="operating"> 
          <a class="href-article-edit slide-toggle">版权</a> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div id="blogHuaweiyunAdvert"></div> 
      <div id="blogColumnPayAdvert"> 
       <div class="column-group"> 
        <div class="column-group-item column-group0 column-group-item-one"> 
         <div class="item-l"> 
          <a class="item-target" href="https://blog.csdn.net/qq_62325622/category_12522101.html" target="_blank" title="操作系统" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.6332&quot;}" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.6332&quot;}"> <img class="item-target" src="https://i-blog.csdnimg.cn/columns/default/20201014180756928.png?x-oss-process=image/resize,m_fixed,h_224,w_224" alt=""> <span class="title item-target"> <span> <span class="tit">操作系统</span> <span class="dec">专栏收录该内容</span> </span> </span> </a> 
         </div> 
         <div class="item-m"> 
          <span>8 篇文章</span> 
         </div> 
         <div class="item-r"> 
          <a class="item-target article-column-bt articleColumnFreeBt" data-id="12522101">订阅专栏</a> 
         </div> 
        </div> 
       </div> 
      </div> 
      <article class="baidu_pl"> 
       <div id="article_content" class="article_content clearfix"> 
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css"> 
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-704d5b9767.css"> 
        <div id="content_views" class="htmledit_views"> 
         <p></p> 
         <blockquote> 
          <p style="margin-left:0px;"><a name="3060-1621846615933"></a>来都来了给我点个赞吧🌹🌹🌹🌹🌹</p> 
         </blockquote> 
         <h2 style="margin-left:0px;">一、操作系统导论</h2> 
         <h4 style="margin-left:0;"><a name="25Na-1689647307076"></a>1.简介</h4> 
         <p style="margin-left:0;"><a name="M9sN-1689647441578"></a><strong>什么是操作系统</strong></p> 
         <p style="margin-left:0;"><a name="XpCT-1689647507028"></a><span style="color:#4d4d4d;">操作系统（Operating Ststem， OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</span></p> 
         <p style="margin-left:0;"><span style="color:#4d4d4d;">1.</span><strong><span style="color:#181e33;">OS </span></strong><strong><span style="color:#181e33;">作为用户与计算机硬件系统之间的接口</span></strong></p> 
         <p style="margin-left:0;"><a name="0P61-1689647921229"></a>OS 作为用户与计算机硬件系统之间接口的含义是：<span style="color:#ff9900;">OS 处于用户与计算机硬件系统之 间，用户通过 OS 来使用计算机系统。</span>或者说，用户在 OS 帮助下，能够方便、快捷、安全、 可靠地操纵计算机硬件和运行自己的程序。应注意，OS 是一个系统软件，因而这种接口是软件接口。图 1-1 是 OS 作为接口的示意图。由图 可看出，用户可通过以下三种方式使用计算机。</p> 
         <p class="img-center"><img alt="" height="207" src="https://i-blog.csdnimg.cn/blog_migrate/d95af58d8ac80fae3594b01a9c4df212.png" width="354"></p> 
         <p style="margin-left:0;"><a name="5iJh-1689647921523"></a></p> 
         <p style="margin-left:0;"><a name="SpwY-1689647921515"></a>&nbsp;(1) 命令方式。这是指由 OS 提供了一组联机 命令接口，以允许用户通过键盘输入有关命令来 取得操作系统的服务，并控制用户程序的运行。</p> 
         <p style="margin-left:0;"><a name="gTFw-1689647921519"></a>&nbsp;(2) 系统调用方式。OS 提供了一组系统调用， 用户可在自己的应用程序中通过相应的系统调 用，来实现与操作系统的通信，并取得它的服务。</p> 
         <p style="margin-left:0;"><a name="RS92-1689647921521"></a>&nbsp;(3) 图形、窗口方式。这是当前使用最为方便、最为广泛的接口，它允许用户通过屏幕 上的窗口和图标来实现与操作系统的通信，并取得它的服务。</p> 
         <p style="margin-left:0;"><strong><span style="color:#181e33;">2.OS </span></strong><strong><span style="color:#181e33;">作为计算机系统资源的管理者&nbsp;</span></strong></p> 
         <p style="margin-left:0;"><a name="czLW-1689647988464"></a>在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分 为四类：<span style="background-color:#38d8f0;">处理器、存储器、I/O 设备以及信息</span>(数据和程序)。相应地，OS 的主要功能也正是 针对这四类资源进行有效的管理，即：处理机管理，用于分配和控制处理机；存储器管理， 主要负责内存的分配与回收； I/O 设备管理，负责 I/O 设备的分配与操纵；文件管理，负责 文件的存取、共享和保护。可见，OS 的确是计算机系统资源的管理者。事实上，当今世界 上广为流行的一个关于 OS 作用的观点，正是把 OS 作为计算机系统的资源管理者。&nbsp;</p> 
         <p style="margin-left:0;"><a name="4GYk-1689648002813"></a>值得进一步说明的是，当一个计算机系统同时供多个用户使用时，用户对系统中共享 资源的需求(包括数量和时间)可能发生冲突，为了管理好这些共享资源(包括硬件和信息)的 使用，操作系统必须记录下各种资源的使用情况，对使用资源的请求进行授权，协调诸用 户对共享资源的使用，避免发生冲突，并计算使用资源的费用等</p> 
         <p style="margin-left:0;"><strong><span style="color:#181e33;">3.OS </span></strong><strong><span style="color:#181e33;">实现了对计算机资源的抽象&nbsp;</span></strong></p> 
         <p style="margin-left:0;"><a name="6tgE-1689648145784"></a>对于一个完全无软件的计算机系统(即裸机)，它向用户提供的是实际硬件接口(物理接 口)，用户必须对物理接口的实现细节有充分的了解，并利用机器指令进行编程，因此该物 理机器必定是难以使用的。为了方便用户使用 I/O 设备，人们在裸机上覆盖上一层 I/O 设备 管理软件，如图 1-2 所示，由它来实现对 I/O 设备操作的细节，并向上提供一组 I/O 操作命令，如 Read 和 Write 命令，用户可利用它来进行数据输入或输出，而无需关心 I/O 是如何 实现的。此时用户所看到的机器将是一台比裸机功能更强、使用更方便的机器。这就是说， 在裸机上铺设的 I/O 软件隐藏了对 I/O 设备操作的具体细节，向上提供了一组抽象的 I/O 设备.</p> 
         <p style="margin-left:0;"><strong><span style="color:#181e33;">4.用户和计算机硬件之间的接口</span></strong></p> 
         <p style="margin-left:0;"><img alt="" height="391" src="https://i-blog.csdnimg.cn/blog_migrate/c52177f533b1e2a3a2083eb72a4646fe.png" width="864"></p> 
         <p style="margin-left:0;"><a name="dPBH-1689658702593"></a></p> 
         <h4 style="margin-left:0;"><a name="d4Pw-1689647619290"></a>2.操作系统的历史</h4> 
         <h5 style="margin-left:0;"><a name="xkc8-1689648212933"></a>2.1无操作系统的计算机系统</h5> 
         <p style="margin-left:0;"><a name="TjIE-1689648253083"></a><strong>（1）人工操作方式</strong></p> 
         <p style="margin-left:0;"><a name="huHb-1689648359440"></a>从第一台计算机诞生(1945 年)到 20 世纪 50 年代中期的计算机，属于第一代计算机。此 时的计算机是利用成千上万个真空管做成的，它的运行速度仅为每秒数千次，但体积却十 分庞大，且功耗也非常高。这时还未出现 OS。计算机操作是由用户(即程序员)采用人工操 作方式直接使用计算机硬件系统，即由程序员将事先已穿孔(对应于程序和数据)的纸带(或 卡片)装入纸带输入机(或卡片输入机)，再启动它们将程序和数据输入计算机，然后启动计 算机运行。当程序运行完毕并取走计算结果之后，才让下一个用户上机。这种人工操作方 式有以下两方面的缺点: &nbsp;</p> 
         <blockquote> 
          <p style="margin-left:0;"><a name="WXU0-1689648359682"></a>(1) 用户独占全机。此时，计算机及其全部资源只能由上机用户独占。&nbsp;</p> 
          <p style="margin-left:0;"><a name="OsPx-1689648359684"></a>(2) CPU 等待人工操作。当用户进行装带(卡)、卸带(卡)等人工操作时，CPU 及内存等 资源是空闲的。</p> 
         </blockquote> 
         <p style="margin-left:0;"><a name="9l3R-1689648375247"></a><span style="color:#181e33;">可见，人工操作方式严重降低了计算机资源的利用率，此即所谓的人机矛盾。随着 CPU 速度的提高和系统规模的扩大，人机矛盾变得日趋严重。</span></p> 
         <p style="margin-left:0;"><span style="color:#181e33;">下面的作业也就是一个程序：</span></p> 
         <p style="margin-left:0;"><img alt="" height="320" src="https://i-blog.csdnimg.cn/blog_migrate/8fdf3155af9afbe13dd390220950b456.png" width="852"></p> 
         <p style="margin-left:0;"><a name="jhiT-1689648434322"></a><strong><span style="color:#181e33;">（2）脱机输入/输出方式</span></strong></p> 
         <p style="margin-left:0;"><a name="3J5p-1689648819515"></a><span style="color:#181e33;">脱机也就是运用了io的方式让电脑操作不是只通过主机来操作数据，认识引进了磁盘的类似概念</span></p> 
         <p style="margin-left:0;"><a name="jt14-1689648447742"></a><span style="color:#181e33;">为了解决人机矛盾及 CPU 和 I/O 设备之间速度不匹配的矛盾，20 世纪 50 年代末出现 了脱机输入/输出(Off-Line I/O)技术。该技术是事先将装有用户程序和数据的纸带(或卡片) 装入纸带输入机(或卡片机)，在一台外围机的控制下，把纸带(卡片)上的数据(程序)输入到 磁带上。当 CPU 需要这些程序和数据时，再从磁带上将其高速地调入内存。&nbsp;</span></p> 
         <p style="margin-left:0;"><a name="bz0t-1689648777836"></a><span style="color:#181e33;">脱机 I/O 方式的主要优点：</span></p> 
         <blockquote> 
          <p style="margin-left:0;">&nbsp;1.<span style="color:#a2e043;">减少了 CPU的空闲时间。</span>装带(卡)、 卸带(卡)以及将数据从低速 I/O 设备送到高 速磁带(或盘)上，都是在脱机情况下进行 的，并不占用主机时间，从而有效地减少了 CPU 的空闲时间，缓和了人机矛盾。&nbsp;</p> 
          <p style="margin-left:0;">2.<span style="color:#a2e043;">提高了 I/O 速度。</span>当 CPU 在运行中需要数据时，是直接从高速的磁带或磁盘上将 数据调入内存的，不再是从低速 I/O 设备上输入，极大地提高了 I/O 速度，从而缓和了 CPU 和 I/O 设备速度不匹配的矛盾，进一步减少了 CPU 的空闲时间。</p> 
         </blockquote> 
         <h5 style="margin-left:0;"><a name="BqHl-1689649377949"></a></h5> 
         <h5 style="margin-left:0;">2.2<span style="color:#181e33;">单道批处理系统</span></h5> 
         <p style="margin-left:0;"><a name="LZ2L-1689649388559"></a>通常是把一批作业以脱机 方式输入到磁带上，并在系统中配上监督程序(Monitor)，在它的控制下使这批作业能一个 接一个地连续处理。其自动处理过程是：首先，由监督程序将磁带上的第一个作业装入内 存，并把运行控制权交给该作业。当该作业处理完成时，又把控制权交还给监督程序，再 由监督程序把磁带(盘)上的第二个作业调入内存。计算机系统就这样自动地一个作业一个作 业地进行处理，直至磁带(盘)上的所有作业全部完成，这样便形成了早期的批处理系统。由 于系统对作业的处理都是成批地进行的，且在内存中始终只保持一道作业，故称此系统为 单道批处理系统(Simple Batch Processing System)。</p> 
         <p style="margin-left:0;text-align:center;"><a name="mfTq-1689649541732"></a></p> 
         <p style="margin-left:0;"><a name="BDur-1689649541734"></a><img alt="" height="314" src="https://i-blog.csdnimg.cn/blog_migrate/0288619d5dba9da6a3cd97fe838b1c8a.png" width="857"></p> 
         <p style="margin-left:0;"><a name="S0se-1689649388703"></a><strong><span style="color:#181e33;">单道批处理系统的特征:</span></strong></p> 
         <p style="margin-left:0;"><a name="Jtcb-1689649576894"></a>(1) 自动性。在顺利情况下，在磁带上的一批作业能自动地逐个地依次运行，而<span style="color:#6ddeff;">无需人 工干预</span>。</p> 
         <p style="margin-left:0;"><a name="tvDm-1689649593037"></a>(2) 顺序性。磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与它们进入内 存的顺序，在正常情况下应完全相同，亦即<span style="color:#6ddeff;">先调入内存的作业先完成</span>。</p> 
         <p style="margin-left:0;"><a name="bhoL-1689649593039"></a>&nbsp;(3) 单道性。内存中<span style="color:#6ddeff;">仅有一道程序运行</span>，即监督程序每次从磁带上只调入一道程序进入 内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</p> 
         <h5 style="margin-left:0;"><a name="EGKS-1689649557996"></a>2.3<span style="color:#181e33;">多道批处理系统</span></h5> 
         <p style="margin-left:0;"><a name="XTxl-1689649406525"></a><strong><span style="color:#181e33;">多道程序设计的基本概念:</span></strong></p> 
         <p style="margin-left:0;"><a name="hAXU-1689654203377"></a>在该系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备 队列”；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享 CPU 和系统中的各种资源。</p> 
         <p style="margin-left:0;"><img alt="" height="322" src="https://i-blog.csdnimg.cn/blog_migrate/4d17c88d6cb2bc1622839f661d27536f.png" width="576"></p> 
         <p style="margin-left:0;"><a name="h4HR-1689654303327"></a><strong><span style="color:#181e33;">多道批处理系统的优缺点</span></strong></p> 
         <p style="margin-left:0;"><a name="QPsx-1689658310017"></a>(1) <span style="background-color:#a2e043;">资源利用率高。由于在内存中驻留了多道程序，它们共享资源，可保持资源处于忙 碌状态</span>，从而使各种资源得以充分利用。</p> 
         <p style="margin-left:0;"><a name="gHMN-1689658322872"></a>(2) 系统吞吐量大。系统吞吐量是指系统在单位时间内所完成的总工作量。能提高系统吞吐量的主要原因可归结为：第一，CPU 和其它资源保持“忙碌”状态； 第二，仅当作业 完成时或运行不下去时才进行切换，系统开销小。</p> 
         <p style="margin-left:0;"><a name="oOpg-1689658322874"></a>(3) 平均周转时间长。作业的周转时间是指从作业进入系统开始，直至其完成并退出系 统为止所经历的时间。在批处理系统中，由于<span style="color:#a2e043;">作业要排队，依次进行处理，因而作业的周转时间较长</span>，通常需几个小时，甚至几天。</p> 
         <p style="margin-left:0;"><a name="4AGF-1689658322876"></a>(4) 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，这对修改和调试程序是极不方便的。</p> 
         <h5 style="margin-left:0;"><a name="b6a8-1689649406673"></a><span style="color:#181e33;">2.4分时系统</span></h5> 
         <p style="margin-left:0;"><a name="Urdc-1689649422638"></a><span style="color:#181e33;">分时系统(Time Sharing System)与多道批处理系统之间有着截然不同的性能差别，</span><span style="color:#a2e043;">它能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。</span><span style="color:#181e33;">它被经常应用于查询系统中，满足许多查询用户的需要。简单来说就是把一个系统再多用户访问的时候给<span style="background-color:#a2e043;">每个用户分一段时间在一段时间没有做完这个任务，也把时间给下一位用户直到循环回来继续执行。</span></span></p> 
         <p style="margin-left:0;"><a name="LPeV-1689658419760"></a></p> 
         <p style="margin-left:0;"><a name="7Es0-1689658419897"></a><strong><span style="color:#181e33;">分时系统的特征</span></strong></p> 
         <p style="margin-left:0;"><a name="zpeK-1689658427963"></a>&nbsp;(1) 多路性。允许在一台主机上同时联接多台联机终端，系统按分时原则为每个用户服 务。宏观上，是多个用户同时工作，共享系统资源；而微观上，则是每个用户作业轮流运 行一个时间片。多路性即同时性，它提高了资源利用率，降低了使用费用，从而促进了计 算机更广泛的应用。&nbsp;</p> 
         <p style="margin-left:0;"><a name="QrmJ-1689658435994"></a>(2) 独立性。每个用户各占一个终端，彼此独立操作，互不干扰。因此，用户所感觉到 的，就像是他一人独占主机。</p> 
         <p style="margin-left:0;"><a name="XkQI-1689658435996"></a>(3) 及时性。用户的请求能在很短的时间内获得响应。此时间间隔是以人们所能接受的 等待时间来确定的，通常仅为 1～3 秒钟。</p> 
         <p style="margin-left:0;"><a name="raeT-1689658435998"></a>(4) 交互性。用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以 请求系统提供多方面的服务，如文件编辑、数据处理和资源共享等。</p> 
         <h5 style="margin-left:0;"><a name="kPEH-1689649422765"></a><span style="color:#181e33;">2.5&nbsp;实时系统</span></h5> 
         <p style="margin-left:0;"><a name="yw0P-1689649444717"></a><span style="color:#181e33;">所谓“实时”，是表示“及时”，而实时系统(Real Time System)是指系统能及时(或即时) 响应外部事件的请求，</span><span style="color:#a2e043;">在规定的时间内完成对该事件的处理，并控制所有实时任务协调一 致地运行</span><span style="color:#181e33;">。例如自动驾驶要在指定的时间内完成任务不然就会出问题</span></p> 
         <p style="margin-left:0;"><a name="sSwq-1689658514307"></a>在实时系统中必然存在着若干个实时任务，这些任务通常与某个(些)外部设备相关，能 反应或控制相应的外部设备，因而带有某种程度的紧迫性。可从不同的角度对实时任务加 以分类。</p> 
         <p style="margin-left:0;"><a name="Xd5n-1689658514671"></a>1) 按任务执行时是否呈现周期性来划分</p> 
         <p style="margin-left:0;"><a name="mqKe-1689658514673"></a>(1) 周期性实时任务。外部设备周期性地发出激励信号给计算机，要求它按指定周期循 环执行，以便周期性地控制某外部设备。&nbsp;</p> 
         <p style="margin-left:0;"><a name="swvY-1689658514675"></a>(2) 非周期性实时任务。外部设备所发出的激励信号并无明显的周期性，但都必须联系 着一个截止时间(Deadline)。它又可分为开始截止时间(某任务在某时间以前必须开始执行) 和完成截止时间(某任务在某时间以前必须完成)两部分。</p> 
         <p style="margin-left:0;"><a name="MZ95-1689658530497"></a></p> 
         <p style="margin-left:0;"><a name="S5cs-1689658514677"></a>2) 根据对截止时间的要求来划分</p> 
         <p style="margin-left:0;"><a name="Jc5V-1689658514679"></a>(1) 硬实时任务(Hard real-time Task)。系统必须满足任务对截止时间的要求，否则可能 出现难以预测的结果。&nbsp;</p> 
         <p style="margin-left:0;"><a name="Fels-1689658514681"></a>(2) 软实时任务(Soft real-time Task)。它也联系着一个截止时间，但并不严格，若偶尔 错过了任务的截止时间，对系统产生的影响也不会太大。</p> 
         <h5 style="margin-left:0;"><a name="xHS6-1689649444860"></a><span style="color:#181e33;">2.6微机操作系统</span></h5> 
         <p style="margin-left:0;"><a name="WmgB-1689658619407"></a><strong><span style="color:#181e33;">1</span></strong><strong><span style="color:#181e33;">．单用户单任务操作系统</span></strong></p> 
         <p style="margin-left:0;"><a name="tQbw-1689658624608"></a><strong><span style="color:#181e33;">2</span></strong><strong><span style="color:#181e33;">．单用户多任务操作系统（windos）</span></strong></p> 
         <p style="margin-left:0;"><a name="Hs1w-1689658630314"></a><strong><span style="color:#181e33;">3</span></strong><strong><span style="color:#181e33;">．多用户多任务操作系统（linux）</span></strong></p> 
         <h4 style="margin-left:0;"><a name="eVO6-1689658743399"></a><span style="color:#181e33;">3.操作系统的基本特征</span></h4> 
         <h5 style="margin-left:0;"><a name="2pJE-1689658760414"></a><span style="color:#555666;">3.1</span><span style="color:#555666;">、</span>并发</h5> 
         <p style="margin-left:0;"><a name="myBy-1689658826162"></a>并发是指两个或多个事件在<strong><span style="color:#ff5e7b;">同一时间间隔</span></strong>内发生。这些事件在宏观上是同时发生的，在微观上是交替发生的。（把并发想成串行就好理解了）</p> 
         <p style="margin-left:0;"><a name="VMNl-1689658832951"></a>易混淆的概念——并行：两个或多个事件在<strong><span style="color:#ff5e7b;">同一时刻</span></strong>同时发生</p> 
         <h5 style="margin-left:0;"><a name="ryg0-1689658775740"></a><span style="color:#555666;">3.2</span><span style="color:#555666;">、共享</span></h5> 
         <p style="margin-left:0;"><a name="Vbbp-1689658853996"></a>共享即资源共享，是指系统中的资源内存中多个并发执行的进程共同使用。</p> 
         <p style="margin-left:0;"><a name="MBe8-1689658854245"></a>所谓的<span style="color:#a2e043;">“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的</span>(即分时共享)</p> 
         <p style="margin-left:0;"><a name="8PvO-1689658859930"></a><img alt="" height="257" src="https://i-blog.csdnimg.cn/blog_migrate/fb9298d6a6457158a11d0747913876c1.png" width="953"></p> 
         <p style="margin-left:0;"><a name="dOZ3-1689658854247"></a>生活实例:</p> 
         <p style="margin-left:0;"><a name="OEhf-1689658854249"></a>互斥共享方式:使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</p> 
         <p style="margin-left:0;"><a name="2sEm-1689658854251"></a>同时共享方式:使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p> 
         <h5 style="margin-left:0;"><a name="6MOG-1689658776567"></a><span style="color:#555666;">3.3</span><span style="color:#555666;">、虚拟</span></h5> 
         <p style="margin-left:0;"><a name="VUgn-1689658873482"></a><span style="color:#4d4d4d;">虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</span></p> 
         <p style="margin-left:0;"><img alt="" height="323" src="https://i-blog.csdnimg.cn/blog_migrate/f29449b24d0d23ae714478608ec8e247.png" width="881"></p> 
         <p style="margin-left:0;"><a name="Z7hi-1689658867942"></a></p> 
         <h5 style="margin-left:0;"><a name="SLS2-1689658777660"></a><span style="color:#555666;">3.4</span><span style="color:#555666;">、异步</span></h5> 
         <p style="margin-left:0;"><a name="BNaX-1689658881524"></a>异步是指，在多道程序环境下，允许多个程序并发执行，但<strong><span style="color:#a2e043;">由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</span>。</strong></p> 
         <ol>
          <li><a name="XziH-1689658881736"></a>只有系统拥有并发性，才有可能导致异步性。</li>
         </ol> 
         <p style="margin-left:0;"><a name="NYY2-1689658883874"></a></p> 
         <h4 style="margin-left:0;"><a name="7yUC-1689658886094"></a>4.操作系统的运行机制和体系结构</h4> 
         <ul>
          <li> <p style="margin-left:0px;">指令</p> </li>
         </ul> 
         <p style="margin-left:0;"><a name="PBhr-1689658917027"></a></p> 
         <ul>
          <li><img alt="" height="264" src="https://i-blog.csdnimg.cn/blog_migrate/38247316d845ee855aa35e8e9f888649.png" width="957">CPU</li>
         </ul> 
         <p style="margin-left:0;"><a name="fXlF-1689658971021"></a></p> 
         <p><img alt="" height="352" src="https://i-blog.csdnimg.cn/blog_migrate/2d5900bdf006a2c5a49e49f7808d94d1.png" width="1029"></p> 
         <ul>
          <li>程序</li>
          <li style="margin-left:0px;"><a name="CyTn-1689658985035"></a><img alt="" height="311" src="https://i-blog.csdnimg.cn/blog_migrate/591c9ef7e8458efe8ce1844d6f0786a1.png" width="1005">操作系统的内核</li>
         </ul> 
         <p style="margin-left:0;"><a name="ZKb9-1689658908497"></a>由于内核划分功能的不同，内核分为大内核和微内核。</p> 
         <p style="margin-left:0;"><a name="ElNx-1689658994043"></a></p> 
         <p style="margin-left:0;"><img alt="" height="425" src="https://i-blog.csdnimg.cn/blog_migrate/514bd3a1e9709a7df22ac316caa2cbf1.png" width="1042"></p> 
         <p style="margin-left:0;"><a name="usNZ-1689658908499"></a>大内核和微内核的优缺点</p> 
         <p style="margin-left:0;"><a name="F1tR-1689658908501"></a>类比:</p> 
         <p style="margin-left:0;"><a name="tQFR-1689658908503"></a>操作系统的体系结构问题与企业的管理问题很相似。</p> 
         <p style="margin-left:0;"><a name="LjnV-1689658908505"></a>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接</p> 
         <p style="margin-left:0;"><a name="X7XD-1689658908507"></a>大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织结构混乱，难以维护。</p> 
         <p style="margin-left:0;"><a name="uXJO-1689658908509"></a>微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护;缺点是效率低。</p> 
         <p style="margin-left:0;"><a name="ijN7-1689659016557"></a></p> 
         <h4 style="margin-left:0;"><a name="bHUz-1689659016674"></a>5.中断和异常</h4> 
         <p style="margin-left:0;"><a name="eTmk-1689659016876"></a>1.概念和作用</p> 
         <p style="margin-left:0;"><a name="5ZEy-1689659016878"></a>中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p> 
         <p style="margin-left:0;"><a name="Foo6-1689659016880"></a>当中断发生时，CPU立即进入核心态</p> 
         <p style="margin-left:0;"><a name="1KEP-1689659016882"></a>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</p> 
         <p style="margin-left:0;"><a name="96aJ-1689659016884"></a>对于不同的中断信号，会进行不同的处理。</p> 
         <p style="margin-left:0;"><a name="rjwh-1689659016886"></a><strong><span style="color:#6ddeff;">有了中断，才能实现多道程序并发执行。</span></strong></p> 
         <p style="margin-left:0;"><a name="KB4Y-1689659016888"></a>“用户态→核心态”是通过中断实现的，并且中断是唯一途径。“核心态→用户态”的切换是通过执行一个特权指令，将程序状态字（ PSW）的标志位设置为 “用户态”。</p> 
         <p style="margin-left:0;"><a name="od0t-1689659016890"></a>2.分类</p> 
         <p style="margin-left:0;"><a name="BFwD-1689659016892"></a>中断信号的来源来自CPU内部称为内中断，外部称为外中断。</p> 
         <p style="margin-left:0;"><img alt="" height="407" src="https://i-blog.csdnimg.cn/blog_migrate/aeee2912f07a553a1f8ecba757580369.png" width="1105"></p> 
         <p style="margin-left:0;"><a name="mPXn-1689659038142"></a></p> 
         <p style="margin-left:0;"><a name="eeq3-1689659039098"></a></p> 
         <p style="margin-left:0;"><a name="voVY-1689659039102"></a></p> 
         <h4 style="margin-left:0;"><a name="kCPo-1689659078520"></a>6.系统调用</h4> 
         <h5 style="margin-left:0;"><a name="GiJ3-1689659148929"></a>6.1.含义</h5> 
         <p style="margin-left:0;"><a name="5qgR-1689659149180"></a>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<span style="color:#a2e043;">应用程序可以发出系统调用请求来获得操作系统的服务。</span></p> 
         <h5 style="margin-left:0;"><a name="NjKy-1689659149182"></a>6.2.作用</h5> 
         <p style="margin-left:0;"><a name="uv1B-1689659149184"></a>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/o操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p> 
         <h5 style="margin-left:0;"><a name="oHaA-1689659149186"></a>6.3.系统调用和库函数的区别</h5> 
         <p style="margin-left:0;"><a name="phJs-1689659149189"></a>编程语言（c,java）中里边有很多库函数，其实它们（不是所有的库函数）就是将系统调用封装起来，隐藏一些细节，使上层进行系统调用更加方便。</p> 
         <h5 style="margin-left:0;"><a name="OLyY-1689659149191"></a>6.4.其他</h5> 
         <p style="margin-left:0;"><a name="aYaL-1689659149193"></a>系统调用发生在用户态，对系统调用的处理发生在核心态。</p> 
         <p style="margin-left:0;"><a name="frPR-1689659149195"></a>执行陷入指令（自陷指令或访管指令）会处理内中断，使处理器（CPU）从用户态进入核心态。</p> 
         <p style="margin-left:0;"><a name="ZLVh-1689659168358"></a></p> 
         <h2 style="margin-left:0;"><a name="Hv7c-1689659168528"></a>二、进程控制</h2> 
         <h4 style="margin-left:0px;"><a name="hYcq-1689744043652"></a>1.进程的定义</h4> 
         <ol>
          <li><a name="etZd-1689744206545"></a> 程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</li>
          <li><a name="5UAR-1689744283960"></a> 进程（Process）的概念：是动态的，是程序的一次执行过程。<strong><em>同一程序多次执行会对应多个进程</em></strong>。</li>
         </ol> 
         <ol>
          <li><a name="FFf9-1689744225681"></a>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</li>
          <li><a name="2Whl-1689744271538"></a>进程是动态的，进程实体是静态的；进程实体反应了进程某一时刻的状态就像视频中的一帧。</li>
          <li><a name="OqXN-1689744271540"></a>进程，’‘用进程实体（进程映像）更准确’‘：由PCB，程序段（代码：指令序列），数据段（运行过程中产生当各种数据）。其中PCB是给操作系统用的，程序段和数据段是给进程自己用的。 
           <ol>
            <li><a name="t1Fz-1689744271542"></a>操作系统对进程进行管理工作所需的信息都存在PCB中。</li>
            <li><a name="7IDH-1689744271544"></a>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</li>
            <li><a name="ANLi-1689744271546"></a><span style="color:#38d8f0;">进程控制块（PCB）：包括进程描述信息（PID，UID），进程控制和管理信息（CPU、磁盘、网络流量；进程当前状态：就绪态阻塞态/运行态），资源分配清单（正在使用哪些文件，I/O，内存），处理机相关信息（PSW各种寄存器用于实现进程切换）</span></li>
            <li><a name="Ramp-1689744271548"></a>PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”。</li>
            <li><a name="YySs-1689744271550"></a>ID（UID）：基本的进程描述信息，可以让操作系统区分各个进程。</li>
           </ol></li>
         </ol> 
         <p style="margin-left:0;"><a name="nXHU-1689744443370"></a>通过任务管理器我们可以发现每个进程不仅仅只有cpu内存磁盘的占用率也是有唯一用来表示进程的PID（process id）</p> 
         <p style="margin-left:0;"><img alt="" height="568" src="https://i-blog.csdnimg.cn/blog_migrate/df47dfbbb1c7e28071b10be1e9333823.png" width="1048"></p> 
         <p style="margin-left:0;"><a name="Xt7m-1689744440534"></a></p> 
         <p style="margin-left:0;"><a name="ipki-1689744440538"></a><strong>程序的运行过程：</strong></p> 
         <p><img alt="" height="606" src="https://i-blog.csdnimg.cn/blog_migrate/9c746be1d45cc72fe6304f495c7bb8a1.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="VYP4-1689744642545"></a></p> 
         <p style="margin-left:0;"><a name="UO3P-1689744642550"></a><strong>进程特征：</strong></p> 
         <p style="margin-left:0;"><a name="8FHZ-1689744809564"></a><img alt="" height="482" src="https://i-blog.csdnimg.cn/blog_migrate/81ed23e659aa88df46df304a1f08fb56.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="2kUy-1689744802712"></a><strong>总结：</strong></p> 
         <p style="margin-left:0;"><a name="oW0t-1689744686547"></a>&nbsp;<img alt="" height="708" src="https://i-blog.csdnimg.cn/blog_migrate/1b02b6a9cc69ab1e49aefb765d7bc2fc.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="dcAM-1689744686551"></a>2.进程的状态和转化、组织</h4> 
         <h5 style="margin-left:0;"><a name="EjYq-1689744849020"></a>2.1.状态</h5> 
         <p style="margin-left:0;"><a name="yAXl-1689744869192"></a>进程是程序的一次执行。在这个执行中，进程的状态有各种变化。为了方便进程管理，把进程分为了，运行态，就绪态，阻塞态、创建态、终止态五种状态。</p> 
         <ol>
          <li><a name="ge3E-1689744974951"></a>创建态：系统创建进程，操作系统给进程分配系统资源、pcb等等</li>
          <li><a name="fDq6-1689745284606"></a>就绪态：已经具备运行条件，等待空闲的cpu，进行调用</li>
          <li><a name="6QlD-1689745079609"></a>运行态：当cpu处于空闲阶段就会在就绪态的进程里面选择一个进行执行，，也就是把cpu占据进入了运行态，一核的cpu就只可以一次运行一个进程，<span style="color:#ed7976;"><strong>多少核的cpu可以有多少个进程处于运行态</strong></span></li>
          <li><a name="YvxR-1689745337966"></a>阻塞态：因为某个事件而暂时不可用运行</li>
          <li><a name="v6wJ-1689745387407"></a>终止态：运行进程从cpu撤销，操作系统就会回收资源、撤销PCB</li>
         </ol> 
         <h4 style="margin-left:0;"><a name="WESS-1689745554689"></a>2.2转化</h4> 
         <p style="margin-left:0;"><a name="yc0X-1689745560537"></a></p> 
         <p style="margin-left:0;"><a name="kuok-1689745575602"></a></p> 
         <p><img alt="" height="566" src="https://i-blog.csdnimg.cn/blog_migrate/94dbfef2b59b28e1ce86c35a236abcca.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="Jfqv-1689745575606"></a></p> 
         <h5 style="margin-left:0;"><a name="bK5x-1689745675961"></a>2.3.进程的组织</h5> 
         <p style="margin-left:0;"><a name="HZ6e-1689745916844"></a>组织也就是调用的方式</p> 
         <p style="margin-left:0;"><a name="4wz2-1689745953727"></a>链式</p> 
         <p style="margin-left:0;"><a name="bqDV-1689745917646"></a></p> 
         <p><img alt="" height="1156" src="https://i-blog.csdnimg.cn/blog_migrate/50aa480adbf27409805979bd4bd137f5.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="lsVv-1689745917650"></a>索引</p> 
         <p style="margin-left:0;"><a name="6vT3-1689745951644"></a></p> 
         <p><img alt="" height="737" src="https://i-blog.csdnimg.cn/blog_migrate/05a465a75d029407cbd841ee66e6e0b6.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="1KSo-1689745951648"></a>3.进程控制</h4> 
         <p style="margin-left:0;"><a name="IKXu-1689746025481"></a><strong>进程控制的含义：进程控制就是要用来实现进程状态的转化的</strong></p> 
         <p style="margin-left:0;"><a name="rKLb-1689746064012"></a></p> 
         <p style="margin-left:0;"><a name="4jGk-1689746100572"></a><strong>进程控制的实现：</strong><span style="color:#4d4d4d;"><span style="background-color:#a2e043;">进程控制由原语实现。</span>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，</span><span style="color:#a2e043;"><strong>在执行过程中不可被中断</strong>。</span><span style="color:#4d4d4d;">原语采用 “关中断指令” 和 “开中断指令” 来实现。 注意： 原语运行在核心态。</span></p> 
         <p style="margin-left:0;"><a name="DuCD-1689746278918"></a>那么原语是如何实现进程状态的转换呢？</p> 
         <ol>
          <li> 
           <ol>
            <li><a name="Jj48-1689746279264"></a> 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境) 
             <ol>
              <li><a name="4GGf-1689746309160"></a> 所有的进程控制原语一定都会修改进程状态标志</li>
              <li><a name="d8LF-1689746279268"></a> 剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li>
              <li><a name="BnF5-1689746279270"></a> 某进程开始运行前必然要恢复期运行环境</li>
             </ol></li>
            <li><a name="zZ1p-1689746279272"></a> 将PCB插入合适的队列</li>
            <li><a name="w3cL-1689746279274"></a> 分配/回收资源</li>
           </ol></li>
         </ol> 
         <p style="margin-left:0;"><a name="xcz5-1689746373851"></a></p> 
         <p><img alt="" height="669" src="https://i-blog.csdnimg.cn/blog_migrate/f47a2d1767909475276fc3c571869422.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="gDy2-1689746373855"></a><strong>程序的运行</strong></p> 
         <p style="margin-left:0;"><a name="EFkR-1689746720889"></a></p> 
         <p><img alt="" height="1200" src="https://i-blog.csdnimg.cn/blog_migrate/b0b7e4c0406e986670621792f05eae28.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="PkyQ-1689746720894"></a>4.进程的通信</h4> 
         <p style="margin-left:0;"><a name="UpWQ-1689746772631"></a><strong>含义：进程通信就是进程之间的信息交换。</strong></p> 
         <p style="margin-left:0;"><a name="imQH-1689746783026"></a>为了保证安全，一个进程不能直接访问另一个进程的地址空间。所以操作系统就提供了三种方法使得进程可以进行信息交换。</p> 
         <p style="margin-left:0;">1.共享存储</p> 
         <p style="margin-left:0;"><a name="98ys-1689746971956"></a></p> 
         <p><img alt="" height="555" src="https://i-blog.csdnimg.cn/blog_migrate/abeaa3fce7046d37bdd5693f0b8e3bbc.png" width="1200">2.消息传递</p> 
         <p style="margin-left:0;"><a name="82yp-1689746986198"></a><span style="color:#4d4d4d;">进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息” 两个原语进行数据交换。</span></p> 
         <p style="margin-left:0;"><img alt="" height="544" src="https://i-blog.csdnimg.cn/blog_migrate/d9d1cf0788ab6e065bde54b2ce33e8f1.png" width="1200"></p> 
         <p style="margin-left:0;"><span style="color:#4d4d4d;">3.</span>管道通信</p> 
         <p style="margin-left:0;"><a name="jhKD-1689747248088"></a>1.<span style="color:#a2e043;">管道只能采用半双工通信，某一时间段内只能实现单向的传输。</span>如果要实现双向同时通信，则需要设置两个管道。</p> 
         <p style="margin-left:0;"><a name="sQVk-1689747257534"></a>2.各进程要互斥地访问管道。</p> 
         <p style="margin-left:0;"><a name="MKoN-1689747257536"></a>3.数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取后，管道变空，此时读进程的read()系统调用将被阻塞。</p> 
         <p style="margin-left:0;"><a name="hBWG-1689747257538"></a>4.如果没写满，就不允许读。如果没读空，就不允许写。</p> 
         <p style="margin-left:0;"><a name="nEan-1689747257540"></a>5．数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</p> 
         <p style="margin-left:0;"><a name="jizZ-1689747280740"></a></p> 
         <p><img alt="" height="380" src="https://i-blog.csdnimg.cn/blog_migrate/3f4adfa9b2ef3e464749857919551ea8.png" width="1133"></p> 
         <p style="margin-left:0;"><a name="yfcs-1689747244792"></a></p> 
         <h4 style="margin-left:0;"><a name="wVUE-1689747305712"></a>5.线程的概念、多线程模型</h4> 
         <h5 style="margin-left:0;"><a name="nMPF-1689747384563"></a>5.1.概念</h5> 
         <p style="margin-left:0;"><a name="ckrM-1689747384973"></a>有的进程需要同时做很多事，例如用QQ来进行聊天，发送文件等，而传统的进程只能串行执行一系列程序。因此，引入“线程”，来增加并发度。</p> 
         <ol>
          <li><a name="wxV2-1689747384975"></a>可以把线程理解为轻量级的进程。</li>
          <li><a name="fALQ-1689747384977"></a>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</li>
          <li><a name="YGTh-1689747384979"></a>引入线程后，进程作为除CPU之外的系统资源的分配单元。</li>
         </ol> 
         <p style="margin-left:0;"><a name="O4KH-1689747414102"></a></p> 
         <p><img alt="" height="379" src="https://i-blog.csdnimg.cn/blog_migrate/e9c7a4b577bdad30ce77cca7b6e450b2.png" width="1041"></p> 
         <h5 style="margin-left:0;"><a name="ZSKp-1689747430920"></a>5.2.线程分类</h5> 
         <ol>
          <li><a name="GggI-1689747434345"></a> 用户级线程</li>
         </ol> 
         <ol>
          <li><a name="6Ozi-1689747632443"></a>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换)</li>
          <li><a name="Ivsb-1689747434349"></a>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li>
          <li><a name="7lCA-1689747434351"></a>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明)</li>
          <li><a name="q7VG-1689747434353"></a>可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”。</li>
         </ol> 
         <ol>
          <li><a name="GSyG-1689747434355"></a> 内核级线程</li>
         </ol> 
         <p style="margin-left:0;"><a name="Heo0-1689747434357"></a>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p> 
         <p style="margin-left:0;"><a name="idXa-1689747434359"></a>可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</p> 
         <p style="margin-left:0;"><a name="CECU-1689747434361"></a>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p> 
         <h5 style="margin-left:0;"><a name="WU1G-1689747414126"></a>5.3.多线程模型</h5> 
         <p style="margin-left:0;"><a name="xRHg-1689747774951"></a>线程模型分为三种：一对一、多对一、多对多</p> 
         <p style="margin-left:0;"><a name="M4xU-1689747793136"></a></p> 
         <p style="margin-left:0;"><a name="MA9z-1689747798729"></a><span style="color:#555666;">一对一模型</span></p> 
         <ol>
          <li><a name="nKKU-1689747798731"></a>一对一模型:一个用户级线程映射到一个内核级线程。</li>
          <li><a name="RMHh-1689747798733"></a>优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。<strong>多线程可在多核处理机上并行执行。</strong></li>
          <li><a name="9rud-1689747798735"></a>缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，<strong>因此线程管理的成本高，开销大。</strong></li>
         </ol> 
         <p style="margin-left:0;"><a name="vsAQ-1689747800495"></a></p> 
         <p style="margin-left:0;"><a name="pX1Y-1689747806177"></a></p> 
         <p><img alt="" height="454" src="https://i-blog.csdnimg.cn/blog_migrate/8de8cdcd5c1fc402def14a4bd1a548a9.png" width="547"></p> 
         <p style="margin-left:0;"><a name="dp0J-1689747806180"></a></p> 
         <p style="margin-left:0;"><a name="MQPg-1689747833640"></a></p> 
         <p style="margin-left:0;"><a name="vVel-1689747874635"></a><span style="color:#555666;">多对一模型</span></p> 
         <p style="margin-left:0;"><a name="BssG-1689747866251"></a>多对一模型:多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p> 
         <p style="margin-left:0;"><a name="nmDD-1689747833642"></a>优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p> 
         <p style="margin-left:0;"><a name="dEoR-1689747833644"></a>缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p> 
         <p style="margin-left:0;"><a name="vkT5-1689747951471"></a></p> 
         <p><img alt="" height="466" src="https://i-blog.csdnimg.cn/blog_migrate/41de990d30e98f93c97597cc22c3708c.png" width="540"></p> 
         <p style="margin-left:0;"><a name="SXfR-1689747882271"></a></p> 
         <p style="margin-left:0;"><a name="pSat-1689747882775"></a><span style="color:#555666;">多对多模型</span></p> 
         <ol>
          <li><a name="KHrM-1689747882777"></a>多对多模型:n用户级线程映射到m个内核级线程(n &gt;=m)。每个用户进程对应m个内核级线程。</li>
          <li><a name="ItIk-1689747967063"></a>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
         </ol> 
         <p style="margin-left:0;"><a name="x2ZF-1689747967065"></a></p> 
         <p style="margin-left:0;"><a name="B5E7-1689747970508"></a></p> 
         <p><img alt="" height="436" src="https://i-blog.csdnimg.cn/blog_migrate/65f3e4417104da7f4ba54f5418332548.png" width="517"></p> 
         <h4 style="margin-left:0;"><a name="TkOF-1689747970512"></a>6.处理机调度</h4> 
         <p style="margin-left:0;"><a name="SugR-1689824661109"></a>首先我们需要认知的是<strong>作业和进程的区别</strong>是什么：</p> 
         <p style="margin-left:0;"><a name="AB0I-1689824783355"></a><span style="color:#4d4d4d;"><span style="background-color:#a2e043;">作业是用户需要计算机完成的某项任务</span>。一个作业的完成要经过作业提交、作业收容、作业执行和作业完成四个阶段。而进程是对已提交完毕的程序所执行过程的描述。</span></p> 
         <p style="margin-left:0;"><a name="evAs-1689824786702"></a>1.作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业作业后，系统将它放入外存中的作业等待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。</p> 
         <p style="margin-left:0;"><a name="oggA-1689824876263"></a>2.一个作业可由多个进程组成，且必须至少由一个进程组成，反过来不成立。</p> 
         <p style="margin-left:0;"><a name="ZOh6-1689824876265"></a>3.作业的概念主要用在批处理系统中，像UNIX这样的分时系统中就没有作业的概念。而进程的概念则用在几乎所有的多道程序系统中。</p> 
         <p style="margin-left:0;"><a name="4ohE-1689824904663"></a></p> 
         <p style="margin-left:0;"><a name="6mIa-1689748120323"></a>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p> 
         <p style="margin-left:0;"><a name="BmAh-1689822929001"></a>调度分为三个层次，分别为高级调度，中级调度，初级调度。</p> 
         <ol>
          <li><a name="tns8-1689822939655"></a> 高级调度</li>
         </ol> 
         <ol>
          <li><a name="QuID-1689823012710"></a>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li>
          <li><a name="UHzz-1689823020165"></a>高级调度（作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB)，以使它（们）获得竞争处理机的权利。</li>
          <li><a name="QKOf-1689823020167"></a>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，调出的时机必然是作业运行结束才调出。</li>
         </ol> 
         <p style="margin-left:0;"><a name="dKQf-1689823040146"></a></p> 
         <p><img alt="" height="235" src="https://i-blog.csdnimg.cn/blog_migrate/901da7fd026c4e798f1ee21dfdba6439.png" width="988"></p> 
         <ol>
          <li><a name="mfgN-1689822945999"></a> 中级调度</li>
         </ol> 
         <ol>
          <li><a name="fYUf-1689823041924"></a>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。</li>
          <li><a name="Q3J7-1689823047288"></a>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</li>
          <li><a name="KoNg-1689823047290"></a>中级调度（内存调度），就是要决定将哪个处于<strong>挂起状态</strong>的进程重新调入内存。</li>
          <li><a name="Ibwp-1689823047292"></a>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</li>
         </ol> 
         <p style="margin-left:0;"><a name="lAay-1689823092232"></a></p> 
         <p><img alt="" height="214" src="https://i-blog.csdnimg.cn/blog_migrate/c6a76da3326b07534784097cce10e542.png" width="1076"></p> 
         <ol>
          <li><a name="nJbu-1689822950061"></a> 初级调度</li>
         </ol> 
         <ol>
          <li><a name="lwmo-1689823255715"></a>低级调度（进程调度），其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li>
          <li><a name="canC-1689823099783"></a>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</li>
          <li><a name="Ilth-1689823099785"></a>进程调度的频率很高，一般几十毫秒一次。</li>
         </ol> 
         <p style="margin-left:0;"><a name="m4bx-1689823123272"></a></p> 
         <p style="margin-left:0;"><a name="NcRg-1689823255894"></a></p> 
         <p><img alt="" height="202" src="https://i-blog.csdnimg.cn/blog_migrate/6e3c79deaf3e7c5d921f1a88f589ab17.png" width="684"></p> 
         <ol>
          <li><a name="LI1P-1689823210057"></a> 三种调度的联系和对比</li>
         </ol> 
         <p style="margin-left:0;"><a name="anU6-1689823268328"></a></p> 
         <p><img alt="" height="306" src="https://i-blog.csdnimg.cn/blog_migrate/c0abf8cdc66560ceb81f932464cf014b.png" width="843"></p> 
         <h4 style="margin-left:0;"><a name="4Lw3-1689823131252"></a>7.进程调度的时机，切换过程</h4> 
         <h5 style="margin-left:0;"><a name="NH36-1689823423162"></a>1.进程调度的时机</h5> 
         <p style="margin-left:0;"><a name="dwZP-1689823455334"></a></p> 
         <p><img alt="" height="489" src="https://i-blog.csdnimg.cn/blog_migrate/f4ca6f8da2838487a76e73ab3eb1daf3.png" width="1165"></p> 
         <p style="margin-left:0;"><a name="swsA-1689823455338"></a>临界资源： 一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。</p> 
         <p style="margin-left:0;"><a name="sHCZ-1689823491375"></a>临界区：访问临界资源的那段代码。</p> 
         <p style="margin-left:0;"><a name="inNC-1689823491377"></a>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列。</p> 
         <h5 style="margin-left:0;"><a name="A2cd-1689823502274"></a>2.进程调度的方式</h5> 
         <ol>
          <li><a name="JVmI-1689823514181"></a>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
         </ol> 
         <p style="margin-left:0;"><a name="m2k6-1689823549974"></a>优点：实现简单,系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p> 
         <ol>
          <li><a name="oy4b-1689823533727"></a>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</li>
         </ol> 
         <p style="margin-left:0;"><a name="8Edj-1689823585742"></a>优点：可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p> 
         <h5 style="margin-left:0;"><a name="xP3n-1689823607761"></a>3.进程的切换与过程</h5> 
         <p style="margin-left:0;"><a name="0F6F-1689823763940"></a><strong>“狭义的进程调度”与“进程切换”的区别</strong>:</p> 
         <ol>
          <li><a name="IMP5-1689823764523"></a>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</li>
          <li><a name="vFmy-1689823764527"></a>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</li>
         </ol> 
         <p style="margin-left:0;"><a name="FpEN-1689823770050"></a><strong>广义的进程调度包含了选择一个进程和进程切换两个步骤</strong>。</p> 
         <p style="margin-left:0;"><a name="iHc5-1689823779300"></a>进程切换的过程主要完成了:</p> 
         <ol>
          <li><a name="0IQh-1689823779302"></a>1.对原来运行进程各种数据的保存</li>
          <li><a name="LWbQ-1689823779304"></a>2.对新的进程各种数据的恢复(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
         </ol> 
         <p style="margin-left:0;"><a name="DN9Y-1689823779306"></a>注意 : 进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p> 
         <p style="margin-left:0;"><a name="u9s9-1689823764529"></a></p> 
         <h4 style="margin-left:0;"><a name="VE5y-1689823854897"></a>8.调度算法的评价指标</h4> 
         <p style="margin-left:0;"><a name="r6Ck-1689824352997"></a>可以看下面调度算法的例题来理解其中的含义是怎么算的</p> 
         <ol>
          <li><a name="oKn1-1689823872560"></a>CPU利用率： CPU"忙碌"的时间占总时间的比例。</li>
          <li><a name="YM8V-1689824001774"></a>系统吞吐量：单位时间内完成作业的数量。</li>
          <li><a name="VmyL-1689824014830"></a>周转时间：是指从作业被提交给系统开始，到作业完成为止的时间间隔。<span style="background-color:#ffffff;"><span style="color:#4d4d4d;">周转时间=作业完成时的时间-作业提交时间</span></span></li>
          <li><a name="toKq-1689824171179"></a><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">平均周转时间=各作业周转时间之和/作业数</span></span></li>
          <li><a name="Nh3R-1689824202620"></a><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">带权周转时间=（作业完成时的时间-作业提交时间）/作业实际运行时间</span></span></li>
          <li><a name="WUTE-1689824073361"></a>等待时间：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</li>
         </ol> 
         <p style="margin-left:0;"><a name="jLH5-1689824074212"></a>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p> 
         <p style="margin-left:0;"><a name="mTDR-1689824074214"></a>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p> 
         <ol>
          <li><a name="2yHt-1689824074216"></a>响应时间：指从用户提交请求到首次产生响应所用的时间。</li>
         </ol> 
         <p style="margin-left:0;"><a name="J07h-1689824452645"></a></p> 
         <h4 style="margin-left:0;"><a name="TBW7-1689824453445"></a>9.调度算法</h4> 
         <h5 style="margin-left:0;"><a name="SYoR-1689827653133"></a>9.1.先来先服务（FCFS，First Come First Serve）</h5> 
         <p style="margin-left:0;"><a name="184S-1689827731892"></a></p> 
         <p><img alt="" height="523" src="https://i-blog.csdnimg.cn/blog_migrate/f2656b735a8624d32fc18eadcdfb8f3f.png" width="1105"></p> 
         <h5 style="margin-left:0;"><a name="Kkku-1689827668625"></a>例题：</h5> 
         <p style="margin-left:0;"><a name="3rWi-1689827844892"></a></p> 
         <p><img alt="" height="1148" src="https://i-blog.csdnimg.cn/blog_migrate/4dc0afa1e1afcc805c07a69a292b9a4f.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="9XmA-1689827735946"></a>9.2.短作业优先（SJF，Shortest Job First）</h5> 
         <p style="margin-left:0;"><a name="3O55-1689831135056"></a></p> 
         <p><img alt="" height="669" src="https://i-blog.csdnimg.cn/blog_migrate/ae84e6774c28bdcbd34aebb4cdf3b573.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="D4ac-1689827981226"></a></p> 
         <p style="margin-left:0;"><a name="O9WJ-1689827974172"></a><strong>非抢占式的作业优先算法</strong></p> 
         <p style="margin-left:0;"><a name="0hDx-1689827886902"></a></p> 
         <p><img alt="" height="1133" src="https://i-blog.csdnimg.cn/blog_migrate/2bd469758aeec3baf20f58bac1dd180f.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="mRkP-1689827674707"></a><strong>抢占式的作业优先算法</strong></p> 
         <p style="margin-left:0;"><a name="FClF-1689827944105"></a></p> 
         <p><img alt="" height="1142" src="https://i-blog.csdnimg.cn/blog_migrate/7b46a6ee34e11ea5c18e04aa2439e080.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="1I2r-1689827943213"></a>9.3.高响应比优先（HRRN，Highest Response Ratio Next）</h5> 
         <p style="margin-left:0;"><a name="dFzn-1689828004769"></a></p> 
         <p style="margin-left:0;"><a name="ti0K-1689831162061"></a></p> 
         <p><img alt="" height="534" src="https://i-blog.csdnimg.cn/blog_migrate/2c644011d20637627f17414913942bec.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="O5Bz-1689831162065"></a>例题：</p> 
         <p style="margin-left:0;"><a name="EFQ1-1689828005972"></a></p> 
         <p><img alt="" height="1101" src="https://i-blog.csdnimg.cn/blog_migrate/eb72810033c515974533db3b5fcc61ef.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="eXLq-1689827684762"></a>9.4.时间片轮转调度（RR，Round-Robin）</h5> 
         <p style="margin-left:0;"><a name="aKI7-1689829483962"></a>时间片就是分配一段时间给进程运行时间到了就会主动的放弃处理机</p> 
         <p style="margin-left:0;"><a name="JPYn-1689831210116"></a></p> 
         <p><img alt="" height="557" src="https://i-blog.csdnimg.cn/blog_migrate/b62ea5897458f5e43df6edb80154d5ab.png" width="1101"></p> 
         <p style="margin-left:0;"><a name="Yeau-1689831187903"></a></p> 
         <p style="margin-left:0;"><a name="btlf-1689829480991"></a></p> 
         <p><img alt="" height="728" src="https://i-blog.csdnimg.cn/blog_migrate/242476447ff1cf84d0c1e78b02020ea0.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="5k8w-1689827689859"></a>9.5.优先级调度算法</h5> 
         <p style="margin-left:0;"><a name="oK51-1689829619175"></a></p> 
         <p style="margin-left:0;"><a name="pXnA-1689831219116"></a></p> 
         <p><img alt="" height="534" src="https://i-blog.csdnimg.cn/blog_migrate/f78e2275af5d1e8a645120b80517ce2a.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="uU0A-1689829589583"></a><strong>非抢占式</strong></p> 
         <p style="margin-left:0;"><a name="NfiS-1689829580987"></a></p> 
         <p><img alt="" height="716" src="https://i-blog.csdnimg.cn/blog_migrate/35deeacf5a46c0e7c0717beddf75f821.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="B0ht-1689829581001"></a><strong>抢占式</strong></p> 
         <p style="margin-left:0;"><a name="a781-1689829567908"></a></p> 
         <p><img alt="" height="783" src="https://i-blog.csdnimg.cn/blog_migrate/e9f0caf977a68b901cd99395bbb26323.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="3K8a-1689827696682"></a>9.6.多级反馈队列调度算法</h5> 
         <p style="margin-left:0;"><a name="A3Pv-1689831229126"></a></p> 
         <p><img alt="" height="622" src="https://i-blog.csdnimg.cn/blog_migrate/15230936ebc86fb9fce4a966b69127f7.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="yt7r-1689829624489"></a></p> 
         <p style="margin-left:0;"><a name="kcHZ-1689831235121"></a></p> 
         <p><img alt="" height="555" src="https://i-blog.csdnimg.cn/blog_migrate/25f3ee65e8457b05eecb995f82808804.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="UTgH-1689831235133"></a></p> 
         <h4 style="margin-left:0;"><a name="e9li-1689831249540"></a>10.进程同步与互斥</h4> 
         <h5 style="margin-left:0;"><a name="2PBn-1689831264312"></a>10.1进程同步</h5> 
         <p style="margin-left:0;"><a name="Satt-1689996312202"></a><span style="color:#4d4d4d;">同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</span></p> 
         <ol>
          <li><a name="pjXX-1689996420730"></a>通过进程通信——管道通信的例子来了解什么是进程同步。</li>
         </ol> 
         <p style="margin-left:0;"><a name="j9hy-1689996432422"></a></p> 
         <p style="margin-left:0;"><a name="caIY-1689996438369"></a></p> 
         <p><img alt="" height="112" src="https://i-blog.csdnimg.cn/blog_migrate/324a0b8be3e25c8f09899e1fcc1b742c.png" width="1016"></p> 
         <p style="margin-left:0;"><a name="Idmr-1689996438373"></a><span style="color:#4d4d4d;">读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又<strong>必须按照“写数据→读数据”的顺序</strong>来执行的。<strong>如何解决这种异步问题，就是“进程同步”所讨论的内容。</strong></span></p> 
         <p style="margin-left:0;"><a name="oAyU-1689996455131"></a></p> 
         <h5 style="margin-left:0;"><a name="0uKA-1689996455313"></a><span style="color:#4d4d4d;">10.2进程互斥</span></h5> 
         <ol>
          <li><a name="WbSy-1689997562984"></a>我们把一个时间段内只允许一个进程使用的资源称为临界资源。</li>
          <li><a name="EjY6-1689997563183"></a>许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
          <li><a name="FqWm-1689997563185"></a>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。</li>
          <li><a name="nYsE-1689997563187"></a><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li>
         </ol> 
         <p style="margin-left:0;"><a name="Ng67-1689997571631"></a></p> 
         <p style="margin-left:0;"><a name="s8kB-1689997578412"></a></p> 
         <p><img alt="" height="271" src="https://i-blog.csdnimg.cn/blog_migrate/f0a5fb94318798f847153004203730c9.png" width="1135"></p> 
         <p style="margin-left:0;"><a name="Pon7-1689997578416"></a><span style="color:#4d4d4d;">对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</span></p> 
         <p style="margin-left:0;"><a name="Lbzl-1689998412735"></a></p> 
         <p style="margin-left:0;"><a name="nmDq-1689998413435"></a></p> 
         <p><img alt="" height="320" src="https://i-blog.csdnimg.cn/blog_migrate/06403eab4471185734c81ec592a55822.png" width="1089"></p> 
         <p style="margin-left:0;"><a name="sHCM-1689998413439"></a>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:</p> 
         <ol>
          <li><a name="YbpP-1689998425229"></a> <strong>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;</strong></li>
          <li><a name="7nbc-1689998425231"></a> <strong>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;</strong></li>
          <li><a name="vhvw-1689998425233"></a> <strong>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿)</strong></li>
          <li><a name="c563-1689998425235"></a> <strong>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</strong></li>
         </ol> 
         <p style="margin-left:0;"><a name="KEm0-1689998538188"></a></p> 
         <h4 style="margin-left:0;"><a name="l3kO-1689998538981"></a>11.进程互斥的软件实现方法</h4> 
         <h5 style="margin-left:0;"><a name="ZbCf-1689998574631"></a>1.单标志法</h5> 
         <p style="margin-left:0;"><a name="eNck-1690000933676"></a><span style="color:#4d4d4d;">算法思想:每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>。</span></p> 
         <p style="margin-left:0;"><a name="ZRyo-1690000965760"></a><span style="color:#4d4d4d;">代码实现</span></p> 
         <p style="margin-left:0;"><a name="N49K-1690000963612"></a></p> 
         <p><img alt="" height="295" src="https://i-blog.csdnimg.cn/blog_migrate/9a5aa8b2cdac57af0962aabb671e93c1.png" width="1141"></p> 
         <p style="margin-left:0;"><a name="k1PS-1690000942573"></a><span style="color:#4d4d4d;">上面的代码如果用turn等于0开始，如果率先得到cpu的进程使p1进程，会使p1进程卡在代码5上，（while循环满足条件虽然没有要执行的语句但是会一直卡在里面），但是当p1的时间片到了，就会给p0进程执行代码，到了p0进入临界区了，又且回到p1进程但是还是继续卡住知道执行了代码3就可以执行进程p1了，但是我们可以发现一个很明显的问题就是，在p1想先访问的时候是不可以访问的，所以这是</span><strong><span style="color:#4d4d4d;"><span style="background-color:#a2e043;">违法了空闲让进的原则</span></span></strong><span style="color:#4d4d4d;"><span style="background-color:#a2e043;">。</span></span></p> 
         <p style="margin-left:0;"><a name="YrIr-1690002931244"></a></p> 
         <h5 style="margin-left:0;"><a name="bLVE-1690000893985"></a>2.双标志先检查法</h5> 
         <p style="margin-left:0;"><a name="adQm-1690003003738"></a>算法思想:设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] =ture”意味着0号进程 P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[li]设为true，之后开始访问临界区。</p> 
         <p style="margin-left:0;"><a name="li0l-1690003015660"></a></p> 
         <p><img alt="" height="298" src="https://i-blog.csdnimg.cn/blog_migrate/f8d0f739c0a232875beb992188f40743.png" width="1157"></p> 
         <p style="margin-left:0;"><a name="msOg-1690003467988"></a><span style="color:#4d4d4d;">若按照①⑤②⑥③⑦…的顺序执行，P0和P1将会同时访问临界区。因此，<strong>双标志先检查法的主要问题是:违反“忙则等待”原则。</strong></span></p> 
         <p style="margin-left:0;"><a name="PK9X-1690003472649"></a><span style="color:#4d4d4d;">原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</span></p> 
         <p style="margin-left:0;"><a name="Asif-1690003409590"></a></p> 
         <h5 style="margin-left:0;"><a name="z8bq-1690003017603"></a>3.双标志后检查法</h5> 
         <p style="margin-left:0;"><a name="NU6I-1690003522452"></a><span style="color:#4e5a70;">算法思想:双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”,但是这两个操作又</span>无法一气呵成,因此导致了两个进程同时进入临界区的问题。因此,人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p> 
         <p style="margin-left:0;"><a name="qGHr-1690003492795"></a></p> 
         <p><img alt="" height="548" src="https://i-blog.csdnimg.cn/blog_migrate/bb7c62cd69363758ad6a2da4171a389c.png" width="1186"></p> 
         <h5 style="margin-left:0;"><a name="MEwP-1690000914448"></a>4.peterson算法</h5> 
         <p style="margin-left:0;"><a name="OqhV-1690003573643"></a><span style="color:#4d4d4d;">算法思想:双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，<strong>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。</strong></span></p> 
         <p style="margin-left:0;"><a name="CjNB-1690003618183"></a></p> 
         <p><img alt="" height="477" src="https://i-blog.csdnimg.cn/blog_migrate/7d9b763ad513db5e04ea24f34c877c0c.png" width="1200"></p> 
         <ol>
          <li><a name="LX5k-1690003618187"></a>Peterson算法用软件方法解决了<strong>进程互斥问题，遵循了空闲让进、忙则等待、有限等待</strong>三个原则，但是依然未遵循让权等待的原则。</li>
          <li><a name="xkWf-1690003840526"></a>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</li>
         </ol> 
         <p style="margin-left:0;"><a name="cUds-1690003912448"></a></p> 
         <h4 style="margin-left:0;"><a name="fMuY-1690003913601"></a>12.进程互斥的硬件实现方法</h4> 
         <h5 style="margin-left:0;"><a name="wdvN-1690003951487"></a>1.中断屏蔽方法</h5> 
         <p style="margin-left:0;"><a name="ZZcD-1690004126083"></a></p> 
         <p><img alt="" height="501" src="https://i-blog.csdnimg.cn/blog_migrate/c191a3c068c93212fe64014f3b00f77b.png" width="1192"></p> 
         <h5 style="margin-left:0;"><a name="MhTw-1690004126087"></a>2.TestAndSet指令</h5> 
         <p style="margin-left:0;"><a name="L4sG-1690004155105"></a></p> 
         <p><img alt="" height="556" src="https://i-blog.csdnimg.cn/blog_migrate/35006101d340edf67917ba3d8ddf2819.png" width="1184"></p> 
         <h5 style="margin-left:0;"><a name="UCJd-1690004155109"></a>3.Swap指令</h5> 
         <p style="margin-left:0;"><a name="5RUO-1690004288150"></a></p> 
         <p><img alt="" height="548" src="https://i-blog.csdnimg.cn/blog_migrate/d04b29f99b3abf107c67b6d3d12238a1.png" width="1117"></p> 
         <p style="margin-left:0;"><a name="ajCE-1690004288154"></a></p> 
         <h4 style="margin-left:0;"><a name="o2fp-1690004295109"></a>13.信号量机制</h4> 
         <h5 style="margin-left:0;"><a name="gDA5-1690004354510"></a>1.什么是信号量</h5> 
         <ol>
          <li><a name="zTf2-1690004367225"></a>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li>
          <li><a name="Ywrk-1690004367227"></a>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量)，**可以用一个信号量来表示系统中某种资源的数量，比如:系统中只有一台打印机，就可以设置一个初值为1的信号量。</li>
          <li><a name="lYkv-1690004367229"></a>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。</li>
          <li><a name="2Dfw-1690004367231"></a>一对原语: wait(S)原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量s其实就是函数调用时传入的一个参数。</li>
          <li><a name="aSeg-1690004367233"></a>wait、signal原语常简称为P、V操作（来自荷兰语proberen和 verhogen)。因此，做题的时候常把wait(S)、 signal(S)两个操作分别写为P(S)、V(S)。</li>
         </ol> 
         <h5 style="margin-left:0;"><a name="0KUx-1690004425666"></a>2.整型信号量</h5> 
         <p style="margin-left:0;"><a name="YxUM-1690004426070"></a>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p> 
         <p style="margin-left:0;"><a name="w55a-1690004426072"></a>与普通整数变量的区别：对信号量的操作只有三种，初始化，P操作，V操作。</p> 
         <p style="margin-left:0;"><a name="CBEM-1690004426074"></a>下面以打印机为例：</p> 
         <p style="margin-left:0;"><a name="HwyM-1690004436748"></a></p> 
         <p style="margin-left:0;"><a name="d6rD-1690004437131"></a></p> 
         <p><img alt="" height="489" src="https://i-blog.csdnimg.cn/blog_migrate/c175525ba75f2419709167047a38c2be.png" width="1155"></p> 
         <h5 style="margin-left:0;"><a name="T9nG-1690004437135"></a>3.记录型信号量</h5> 
         <p style="margin-left:0;"><a name="mT18-1690004442169"></a>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用<strong>记录型数据结构表示的信号量</strong>。</p> 
         <p style="margin-left:0;"><a name="Ygk8-1690004449939"></a></p> 
         <p><img alt="" height="523" src="https://i-blog.csdnimg.cn/blog_migrate/903a6764409b72b305f53d6161b4fb77.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="jhBr-1690004449943"></a></h4> 
         <h4 style="margin-left:0;"><a name="F4Qs-1690004623800"></a>14.用信号量实现进程互斥，同步，前驱关系</h4> 
         <h5 style="margin-left:0;"><a name="GAXK-1690004628033"></a>1.信号量机制实现进程互斥</h5> 
         <ol>
          <li><a name="ZDiE-1690004632808"></a> 分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区)</li>
          <li><a name="j6z4-1690004632810"></a> 设置互斥信号量mutex，初值为1</li>
          <li><a name="DRwf-1690004632812"></a> 在临界区之前执行P(mutex) P是对信号量进行减少操作</li>
          <li><a name="fJEm-1690004632814"></a> 在临界区之后执行V(mutex) V是对信号量进行加操作，释放资源</li>
         </ol> 
         <p style="margin-left:0;"><a name="uQH0-1690004681813"></a><strong>先P后V</strong></p> 
         <p style="margin-left:0;"><a name="JEFd-1690004683291"></a></p> 
         <p><img alt="" height="497" src="https://i-blog.csdnimg.cn/blog_migrate/e2b1fa1bf4fb2b46a0dd2dec6aeb4182.png" width="432"></p> 
         <p style="margin-left:0;"><a name="TU2m-1690004683295"></a>注意： 对不同的临界资源（如摄像头，打印机）需要设置不同的互斥信号量。</p> 
         <p style="margin-left:0;"><a name="soif-1690004737361"></a><strong>P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</strong></p> 
         <p style="margin-left:0;"><a name="LXjk-1690004744606"></a></p> 
         <h5 style="margin-left:0;"><a name="fyNo-1690004744783"></a>2.信号量机制实现进程同步</h5> 
         <p style="margin-left:0;"><a name="tX5U-1690004753673"></a>进程同步：要让各并发进程按要求有序的进行。</p> 
         <p style="margin-left:0;"><a name="192v-1690004753675"></a>那么如何实现呢？</p> 
         <ol>
          <li><a name="h1cu-1690004753677"></a> 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码)</li>
          <li><a name="Kc7O-1690004753679"></a> 设置同步信号量s,初始为0</li>
          <li><a name="o3Id-1690004753681"></a> 在“前操作”之后执行v(S)</li>
          <li><a name="kMGt-1690004753683"></a> 在“后操作”之前执行P(S)</li>
         </ol> 
         <p style="margin-left:0;"><a name="O6QD-1690004753685"></a>下面通过一个例子来解释，要求：进程2的代码4必须在进程1的代码2之后执行。</p> 
         <p style="margin-left:0;"><a name="hMDX-1690004799676"></a></p> 
         <p><img alt="" height="388" src="https://i-blog.csdnimg.cn/blog_migrate/e3ac6981632dc3e5d4fcf1e5fc2450fd.png" width="1132"></p> 
         <p style="margin-left:0;"><a name="LWkx-1690004799681"></a></p> 
         <h4 style="margin-left:0;"><a name="3ukC-1690004803087"></a>3.信号量机制实现前驱关系</h4> 
         <p style="margin-left:0;"><a name="aj3M-1690004809326"></a>进程P1中有句代码S1，P2中有句代码S2 …P… P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行:</p> 
         <p style="margin-left:0;"><a name="LQ8U-1690004809328"></a>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作)，因此，</p> 
         <ol>
          <li><a name="AaoD-1690004809330"></a> 要为每一对前驱关系各设置一个同步变量</li>
          <li><a name="f5hd-1690004809332"></a> 在“前操作”之后对相应的同步变量执行V操作</li>
          <li><a name="miBA-1690004809334"></a> 在“后操作”之前对相应的同步变量执行Р操作</li>
         </ol> 
         <p style="margin-left:0;"><a name="8fyK-1690004829468"></a></p> 
         <p><img alt="" height="503" src="https://i-blog.csdnimg.cn/blog_migrate/525a1f4f8375a055b8ae7999c9a2c78c.png" width="491"></p> 
         <p style="margin-left:0;"><a name="hZFs-1690004829471"></a></p> 
         <p style="margin-left:0;"><a name="iILc-1690004933516"></a></p> 
         <h4 style="margin-left:0;"><a name="eUIg-1690005110012"></a>15.生产者——消费者问题</h4> 
         <h5 style="margin-left:0;"><a name="1DeG-1690005110485"></a>1.问题描述</h5> 
         <p style="margin-left:0;"><a name="GmjU-1690005110487"></a>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注:这里的“产品”理解为某种数据)</p> 
         <ol>
          <li><a name="UDAP-1690005110489"></a>生产者、消费者共享一个初始为空、大小为n的缓冲区。</li>
          <li><a name="877h-1690005110491"></a>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>
          <li><a name="tY4w-1690005110493"></a>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
          <li><a name="ZFB7-1690005110495"></a>缓冲区是临界资源，各进程必须互斥地访问。</li>
         </ol> 
         <p style="margin-left:0;"><a name="9g1w-1690005544807"></a></p> 
         <p><img alt="" height="357" src="https://i-blog.csdnimg.cn/blog_migrate/0a9294e98a43304286d2e12772c63a63.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="6HvT-1690005110497"></a>2.问题分析</h5> 
         <p style="margin-left:0;"><a name="pH0f-1690005565829"></a></p> 
         <p><img alt="" height="654" src="https://i-blog.csdnimg.cn/blog_migrate/b112aee4dda1e51154348f04481e318d.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="oDKM-1690005110499"></a>3.如何实现</h5> 
         <p style="margin-left:0;"><a name="8rGS-1690005591844"></a></p> 
         <p><img alt="" height="558" src="https://i-blog.csdnimg.cn/blog_migrate/ca18f2874c95dd38fd8f2e2996b88d62.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="rRyf-1690005110501"></a>4.能够改变相邻P，V的顺序</h5> 
         <p style="margin-left:0;"><a name="EPXG-1690005655667"></a></p> 
         <p><img alt="" height="715" src="https://i-blog.csdnimg.cn/blog_migrate/f1087c24204ade25f3572db7aa39c5a1.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="yNp8-1690005110503"></a>16.多生产者——多消费者</h4> 
         <h5 style="margin-left:0;"><a name="cn8k-1690005110505"></a>1.问题描述</h5> 
         <p style="margin-left:0;"><a name="RsXy-1690005110507"></a>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p> 
         <h5 style="margin-left:0;"><a name="8LPS-1690005110509"></a>2.如何实现</h5> 
         <p style="margin-left:0;"><a name="oNlH-1690006015681"></a></p> 
         <p><img alt="" height="637" src="https://i-blog.csdnimg.cn/blog_migrate/06bb19fd3195a51f92d519f93d4f8230.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="sgxv-1690005110511"></a>问题：可不可以不使用问题信号量？</p> 
         <p style="margin-left:0;"><a name="Jvow-1690005110513"></a>.结论:即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p> 
         <p style="margin-left:0;"><a name="ORif-1690005110515"></a>原因在于:本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻,最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…</p> 
         <p style="margin-left:0;"><a name="EHl4-1690005110517"></a>如果盘子（缓冲区）数量为2，可能会出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。</p> 
         <h5 style="margin-left:0;"><a name="7Dn6-1690005110519"></a>3.总结</h5> 
         <p style="margin-left:0;"><a name="Nl7V-1690005110521"></a>在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p> 
         <p style="margin-left:0;"><a name="UJ7w-1690005110523"></a>建议:在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p> 
         <h4 style="margin-left:0;"><a name="p5RE-1690005110525"></a>17.吸烟者问题</h4> 
         <h5 style="margin-left:0;"><a name="aymj-1690005110527"></a>1.问题描述</h5> 
         <p style="margin-left:0;"><a name="ttPK-1690005110529"></a>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。</p> 
         <p style="margin-left:0;"><a name="mkGU-1690006073983"></a></p> 
         <p><img alt="" height="436" src="https://i-blog.csdnimg.cn/blog_migrate/ed741cfd755d43d3f54a9c47345972bf.png" width="1136"></p> 
         <h5 style="margin-left:0;"><a name="OAOn-1690005110531"></a>2.如何解决</h5> 
         <p style="margin-left:0;"><a name="3jnW-1690005343593"></a>也就是先i=0的时候取出组合1放在桌子上然后就给finish加锁，生产者就被锁在了P（finish）处，在这之前要是有smokern在进程中了也会被P（offern）阻塞住，知道生产者告诉吸烟者才会把烟卷起来抽掉，再释放finish，生产者又可以继续的生成了就是这样的过程实现让三个抽烟者循环抽烟</p> 
         <p style="margin-left:0;"><a name="lqcV-1690005270632"></a></p> 
         <p><img alt="" height="720" src="https://i-blog.csdnimg.cn/blog_migrate/0ced7f3816f1218b35d1e3d8a0a2bda2.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="VmI5-1690005110533"></a>18.读者——写者问题</h4> 
         <h5 style="margin-left:0;"><a name="r6yg-1690005110535"></a>1.问题描述</h5> 
         <p style="margin-left:0;"><a name="LQFy-1690005110537"></a>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:</p> 
         <p style="margin-left:0;"><a name="EAKF-1690005110540"></a>①允许多个读者可以同时对文件执行读操作;</p> 
         <p style="margin-left:0;"><a name="28PS-1690005110542"></a>②只允许一个写者往文件中写信息;</p> 
         <p style="margin-left:0;"><a name="a9Dc-1690005110544"></a>③任一写者在完成写操作之前不允许其他读者或写者工作;</p> 
         <p style="margin-left:0;"><a name="IxZ2-1690005110546"></a>④写者执行写操作前，应让已有的读者和写者全部退出。</p> 
         <p style="margin-left:0;"><a name="3uKL-1690005221728"></a></p> 
         <p><img alt="" height="452" src="https://i-blog.csdnimg.cn/blog_migrate/e6ba3f54f44d7f698144b5b876bf27bf.png" width="1190"></p> 
         <h5 style="margin-left:0;"><a name="9IxW-1690005110548"></a>2.如何实现</h5> 
         <p style="margin-left:0;"><a name="5QJb-1690005240749"></a></p> 
         <p><img alt="" height="580" src="https://i-blog.csdnimg.cn/blog_migrate/cd2fbf416ffa2844cb4942297fb9e19c.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="9OP4-1690005110550"></a>潜在的问题：只要读进程还在读，写进程就要一直堵塞等待，可能会饿死。因此在这种算法中，读进程优先。下面来实现“ 先来先服务”算法，这样就不会导致写进程饿死。</p> 
         <p style="margin-left:0;"><a name="FNtr-1690005249032"></a></p> 
         <p><img alt="" height="551" src="https://i-blog.csdnimg.cn/blog_migrate/f366170a7fe4ccc9819248f7735c9116.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="PObU-1690005110552"></a>3.总结</h5> 
         <p style="margin-left:0;"><a name="D2IL-1690005110554"></a>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p> 
         <p style="margin-left:0;"><a name="Bgmz-1690005110556"></a>其核心思想在于设置了一个计数器count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p> 
         <p style="margin-left:0;"><a name="wRND-1690005110558"></a>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。</p> 
         <p style="margin-left:0;"><a name="4NL5-1690005110560"></a>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p> 
         <h4 style="margin-left:0;"><a name="rkRa-1690005110562"></a>19.哲学家吃饭</h4> 
         <h5 style="margin-left:0;"><a name="6Ch2-1690005110564"></a>1.问题描述</h5> 
         <p style="margin-left:0;"><a name="DnWx-1690005110566"></a>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p> 
         <p style="margin-left:0;"><a name="ruY5-1690006103457"></a></p> 
         <p><img alt="" height="464" src="https://i-blog.csdnimg.cn/blog_migrate/18782383a438e5f2dae25424529d9d1c.png" width="526"></p> 
         <h5 style="margin-left:0;"><a name="Oh5n-1690005110568"></a>2.问题分析</h5> 
         <p style="margin-left:0;"><a name="e7LK-1690005110570"></a>1.关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p> 
         <p style="margin-left:0;"><a name="f7GZ-1690005110572"></a>2.整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</p> 
         <p style="margin-left:0;"><a name="9PZK-1690005110574"></a>3.信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}，用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p> 
         <h5 style="margin-left:0;"><a name="1sKt-1690005110576"></a>3.如何实现</h5> 
         <p style="margin-left:0;"><a name="v0JJ-1690005110578"></a>如果使用下图所示的方法，图中方法也就是哲学家都先拿自己左边的筷子，然后等着拿自己右边的筷子，要是每个哲学家同时拿自己左边的筷子就会导致<strong>死锁问题</strong>。</p> 
         <p style="margin-left:0;"><a name="ChpL-1690006123004"></a></p> 
         <p><img alt="" height="486" src="https://i-blog.csdnimg.cn/blog_migrate/0b3440115fcf364be32879235edb9988.png" width="1195"></p> 
         <p style="margin-left:0;"><a name="qnRk-1690005110580"></a>那么如何解决呢？</p> 
         <p style="margin-left:0;"><a name="44AO-1690005110582"></a>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p> 
         <p style="margin-left:0;"><a name="mkZ2-1690005110584"></a>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p> 
         <p style="margin-left:0;"><a name="rdH6-1690005110586"></a>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p> 
         <p style="margin-left:0;"><a name="v0Vf-1690005110588"></a>下面用代码实现第三种方式。</p> 
         <p style="margin-left:0;"><a name="Z1iN-1690006210030"></a></p> 
         <p><img alt="" height="412" src="https://i-blog.csdnimg.cn/blog_migrate/f61e640911d574eee416cb71545f3ab1.png" width="565"></p> 
         <h4 style="margin-left:0;"><a name="wltL-1690005110590"></a>20.管程</h4> 
         <p style="margin-left:0;"><a name="Akmn-1690005110592"></a><strong>1.</strong><strong>为什么引入管程？</strong></p> 
         <p style="margin-left:0;"><a name="PSPz-1690005110594"></a>信号量机制存在的问题 : 编写程序困难、易出错。 因此人们想设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松。1973年，Brinch Hansen首次在程序设计语言(Pascal)中引入了“管程”成分――一种高级同步机制。</p> 
         <h5 style="margin-left:0;"><a name="FW06-1690005110596"></a>2.管程的定义和基本特征</h5> 
         <p style="margin-left:0;"><a name="0qcG-1690005110598"></a>管程相当于对临界区资源进行抽象而编写的一个类。</p> 
         <p style="margin-left:0;"><a name="Q6wJ-1690005110600"></a>管程是一种特殊的软件模块，有这些部分组成:</p> 
         <ol>
          <li><a name="ipnK-1690005110602"></a> 局部于管程的共享数据结构说明; （一个类）</li>
          <li><a name="zSmX-1690005110604"></a> 对该数据结构进行操作的一组过程; （类中的方法）</li>
          <li><a name="4Vh6-1690005110606"></a> 对局部于管程的共享数据设置初始值的语句; （类中的变量）</li>
          <li><a name="UQJW-1690005110608"></a> 管程有一个名字。 （类名）</li>
         </ol> 
         <p style="margin-left:0;"><a name="ZeIY-1690005110610"></a><strong>管程的基本特征:</strong></p> 
         <ol>
          <li><a name="aIz2-1690005110612"></a> 局部于管程的数据只能被局部于管程的过程所访问; （类中变量有自己的作用范围）</li>
          <li><a name="k8dc-1690005110614"></a> 一个进程只有通过调用管程内的过程才能进入管程访问共享数据; ** 这种互斥特性是由编译器来实现的。</li>
          <li><a name="D4w7-1690005110616"></a> 每次仅允许一个进程在管程内执行某个内部过程。</li>
         </ol> 
         <h5 style="margin-left:0;"><a name="DDAq-1690005110618"></a>3.java中类似于管程的机制（单例模式）</h5> 
         <p style="margin-left:0;"><a name="ZYcQ-1690006229595"></a></p> 
         <p style="margin-left:0;"><a name="ZpMe-1690006230034"></a></p> 
         <p><img alt="" height="381" src="https://i-blog.csdnimg.cn/blog_migrate/281f7ecdaef783f814245f30bf64498c.png" width="1168"></p> 
         <p style="margin-left:0;"><a name="3mAY-1690006230038"></a></p> 
         <h4 style="margin-left:0;"><a name="DLLF-1690006285813"></a>21.死锁</h4> 
         <h5 style="margin-left:0;"><a name="R70S-1690010377471"></a>1.含义</h5> 
         <p style="margin-left:0;"><a name="pDBx-1690010382002"></a>在并发环境下，<strong>各进程因竞争资源而造成的一种互相等待对方手里的资源</strong>，导致各进程都阻塞，都无法向前推进的现象，就是“死锁“。</p> 
         <h4 style="margin-left:0;"><a name="7m0V-1690010450777"></a>2.死锁，饥饿，死循环的区别</h4> 
         <ol>
          <li><a name="1zdh-1690010455395"></a>死锁:各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li>
          <li><a name="G4l8-1690010455397"></a>饥饿:由于长期得不到想要的资源，某进程无法向前推进的现象。比如:在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li>
          <li><a name="nl0H-1690010455399"></a>死循环:某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。</li>
         </ol> 
         <h5 style="margin-left:0;"><a name="jHK3-1690010477618"></a>3.死锁产生的必要条件</h5> 
         <p style="margin-left:0;"><a name="gwMc-1690010478339"></a>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p> 
         <ol>
          <li><a name="Q5Hl-1690010478341"></a>互斥条件:只有对<strong>必须互斥使用的资源</strong>的争抢才会导致死锁(如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源）。</li>
          <li><a name="GE1b-1690010478343"></a>不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，<strong>只能主动释放。</strong></li>
          <li><a name="myQ7-1690010478345"></a>请求 和 保持条件:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
          <li><a name="YJ6q-1690010478347"></a>循环等待条件:存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
         </ol> 
         <p style="margin-left:0;"><a name="0zho-1690010478349"></a>注意 : 发生死锁时一定有循环等待 , 但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件)</p> 
         <p style="margin-left:0;"><a name="yaM8-1690010478351"></a>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p> 
         <h5 style="margin-left:0;"><a name="V3Ed-1690010568377"></a>4.什么时候会发生死锁</h5> 
         <ol>
          <li><a name="TXm4-1690010568587"></a> 对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的</li>
          <li><a name="TMa4-1690010568589"></a> 进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程p1又紧接着申请资源R2，而进程p2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
          <li><a name="DgxH-1690010568591"></a> 信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>
         </ol> 
         <p style="margin-left:0;"><a name="PRgg-1690010631829"></a></p> 
         <h5 style="margin-left:0;"><a name="goCk-1690010632415"></a>5.死锁的处理策略</h5> 
         <ol>
          <li><a name="8dfq-1690010637925"></a> 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li>
          <li><a name="C0dZ-1690010637927"></a> 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法)</li>
          <li><a name="RDdv-1690010637929"></a> 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
         </ol> 
         <p style="margin-left:0;"><a name="BLef-1690010646244"></a></p> 
         <h4 style="margin-left:0;"><a name="LmfE-1690010649560"></a>22.避免死锁</h4> 
         <p style="margin-left:0;"><a name="kqSs-1690010705514"></a>1.什么是安全序列</p> 
         <p style="margin-left:0;"><a name="ERCA-1690010694294"></a></p> 
         <p><img alt="" height="629" src="https://i-blog.csdnimg.cn/blog_migrate/3805f9e3c0cb6670466aaa6fc4ae1fad.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="bfr4-1690010700600"></a></p> 
         <p><img alt="" height="274" src="https://i-blog.csdnimg.cn/blog_migrate/1b7f04c45a043ff9bf753fe18692bbd4.png" width="1183"></p> 
         <ol>
          <li><a name="676r-1690010673209"></a>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</li>
          <li><a name="5h2K-1690010673211"></a>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</li>
          <li><a name="F80R-1690010673213"></a>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，则可能会发生死锁。（不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</li>
          <li><a name="ZqB3-1690010673215"></a>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</li>
         </ol> 
         <p style="margin-left:0;"><a name="NaAI-1690010673217"></a>2.银行家算法</p> 
         <p style="margin-left:0;"><a name="U2Id-1690010673219"></a><strong>数据结构:</strong></p> 
         <p style="margin-left:0;"><a name="u84L-1690010673221"></a>长度为m的一维数组 Available表示还有多少可用资源</p> 
         <p style="margin-left:0;"><a name="HR7H-1690010673223"></a>nm矩阵Max表示各进程对资源的最大需求数</p> 
         <p style="margin-left:0;"><a name="1ant-1690010673225"></a>nm矩阵Allocation表示已经给各进程分配了多少资源</p> 
         <p style="margin-left:0;"><a name="lpk7-1690010673227"></a>Max - Allocation = Need矩阵表示各进程最多还需要多少资源</p> 
         <p style="margin-left:0;"><a name="LZrt-1690010673229"></a>用长度为m的一位数组Request表示进程此次申请的各种资源数</p> 
         <p style="margin-left:0;"><a name="rzU5-1690010673231"></a><strong>银行家算法步骤:</strong></p> 
         <p style="margin-left:0;"><a name="BCCL-1690010673233"></a>①检查此次申请是否超过了之前声明的最大需求数</p> 
         <p style="margin-left:0;"><a name="ELva-1690010673235"></a>②检查此时系统剩余的可用资源是否还能满足这次请求</p> 
         <p style="margin-left:0;"><a name="r08Q-1690010673237"></a>③试探着分配，更改各数据结构</p> 
         <p style="margin-left:0;"><a name="efSM-1690010673239"></a>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p> 
         <p style="margin-left:0;"><a name="9qcs-1690010673241"></a><strong>安全性算法步骤:</strong></p> 
         <p style="margin-left:0;"><a name="6mQQ-1690010673243"></a>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</p> 
         <p style="margin-left:0;"><a name="HxZ6-1690010673245"></a>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p> 
         <p style="margin-left:0;"><a name="4Jxq-1690177196443"></a></p> 
         <h2 style="margin-left:0;"><a name="j4mM-1690177196959"></a>三、内存管理</h2> 
         <h4 style="margin-left:0;"><a name="zaTe-1690177212731"></a>1.基础</h4> 
         <p style="margin-left:0;"><a name="XhlO-1690177222641"></a><strong>内存是用于存放数据的硬件。程序执行之前需要先放在内存中才可以被cpu执行。</strong></p> 
         <p style="margin-left:0;"><a name="Nlko-1690177284370"></a></p> 
         <p><img alt="" height="426" src="https://i-blog.csdnimg.cn/blog_migrate/49d0603399ceb85e402110952e81eb09.png" width="836"></p> 
         <p style="margin-left:0;"><a name="wtcH-1690177284375"></a><strong><em><u>相对地址和绝对地址</u></em></strong></p> 
         <p style="margin-left:0;"><a name="Yqrz-1690177555391"></a><strong>编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</strong></p> 
         <p style="margin-left:0;"><a name="72dh-1690178216049"></a>Eg: 编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU 想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p> 
         <p style="margin-left:0;"><a name="6arx-1690178216051"></a>相对地址又称逻辑地址，绝对地址又称物理地址。</p> 
         <p style="margin-left:0;"><a name="6BsL-1690178744851"></a></p> 
         <p style="margin-left:0;"><a name="EyMf-1690178583933"></a><strong><em><u>⭐⭐⭐编址方式，位 (bit)、字节 (Byte)、字 (word) 的区别</u></em></strong></p> 
         <ol>
          <li><a name="n0b7-1690178765119"></a> <strong>按位编址：1b</strong></li>
          <li><a name="4zO6-1690183610070"></a> <strong>按字节编址： 1Byte=8bit</strong></li>
          <li><a name="oFbW-1690178827373"></a> <strong>按字编址： 机器字长1word=32/64b</strong></li>
         </ol> 
         <p style="margin-left:0;"><a name="Mgcu-1690183632464"></a><strong>1</strong><strong>字节=8位 也就是 1byte=8bit</strong></p> 
         <p style="margin-left:0;"><a name="lWse-1690183674477"></a><strong>1kB=1024B=2^10B</strong></p> 
         <p style="margin-left:0;"><a name="XgFh-1690183698515"></a><strong>1MB=1024kB=2^20B</strong></p> 
         <p style="margin-left:0;"><a name="XEUz-1690183719086"></a><strong>1GB=1024MB=2^30B</strong></p> 
         <p style="margin-left:0;"><a name="BP2A-1690183739350"></a><strong>1TB=1024GB=2^40B</strong></p> 
         <p style="margin-left:0;"><a name="orIf-1690183752980"></a><strong>例题</strong></p> 
         <blockquote> 
          <p style="margin-left:0;"><a name="KJsx-1690183785715"></a><strong><span style="color:#4d4d4d;">计算机字长（word）为32位，存储容量为16MB，按字节编址和字编制的时候，它的寻址范围分别为多少？</span></strong></p> 
          <p style="margin-left:0;"><a name="sxRy-1690183944882"></a><strong><span style="color:#4d4d4d;">寻址范围：存储容量/编址大小（单位都是B）</span></strong></p> 
          <p style="margin-left:0;"><a name="96hE-1690183799052"></a><span style="color:#4d4d4d;">1.</span><span style="color:#4d4d4d;">按照字节编址： 16MB=2^24B=2^24*8bit=2^27bit</span></p> 
          <p style="margin-left:0;"><a name="fDpt-1690184183224"></a><span style="color:#4d4d4d;">寻址范围:&nbsp; (2^27b)/8b=2^24b</span></p> 
          <p style="margin-left:0;"><a name="IuAS-1690184231769"></a><span style="color:#4d4d4d;">2.</span><span style="color:#4d4d4d;">按字寻址:&nbsp;&nbsp;&nbsp;&nbsp; (2^27bit)/32bit=2^22bit</span></p> 
         </blockquote> 
         <h4 style="margin-left:0;"><a name="y0yz-1690183788573"></a>2.内存管理</h4> 
         <p style="margin-left:0;"><a name="ToHn-1690184366720"></a>操作系统对内存进行管理，那么要管理哪些内容呢？</p> 
         <ol>
          <li><a name="Zslj-1690184378030"></a> 内存空间的分配和回收</li>
          <li><a name="Fe25-1690184378032"></a> 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</li>
          <li><a name="V9dQ-1690184378034"></a> 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li>
         </ol> 
         <p style="margin-left:0;"><a name="m29X-1690184378036"></a></p> 
         <p style="margin-left:0;"><a name="mDpm-1690184378042"></a></p> 
         <p><img alt="" height="246" src="https://i-blog.csdnimg.cn/blog_migrate/f95adfdb31584355ecf560b877566491.png" width="1026"></p> 
         <ol>
          <li><a name="q3La-1690184378039"></a> 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li>
         </ol> 
         <p style="margin-left:0;"><a name="xLbI-1690184415463"></a>内存保护可采取两种方法:</p> 
         <p style="margin-left:0;"><a name="W09S-1690184416142"></a>方法一:在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p> 
         <p style="margin-left:0;"><a name="k4bU-1690184423972"></a></p> 
         <p><img alt="" height="344" src="https://i-blog.csdnimg.cn/blog_migrate/92f799cec3611e2849c445db7c2aff3d.png" width="398"></p> 
         <p style="margin-left:0;"><a name="8XE0-1690184416144"></a>方法二:采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</p> 
         <p style="margin-left:0;"><a name="vC6c-1690184428902"></a></p> 
         <p style="margin-left:0;"><a name="cpOH-1690184429976"></a></p> 
         <p><img alt="" height="328" src="https://i-blog.csdnimg.cn/blog_migrate/9ce669c2864b57ddf7b698f7d07d4b09.png" width="780"></p> 
         <h4 style="margin-left:0;"><a name="PHNK-1690184429980"></a>3.覆盖和交换</h4> 
         <p style="margin-left:0;"><a name="YJZ9-1690184472802"></a></p> 
         <p></p> 
         <h5 style="margin-left:0;"><a name="cpt9-1690184455869"></a>1.覆盖技术</h5> 
         <p style="margin-left:0;"><a name="ClDJ-1690184455871"></a>覆盖技术的思想 : <strong>将程序分为多个段（多个模块</strong>）。常用的段常驻内存，不常用的段在需要时调入内存。</p> 
         <p style="margin-left:0;"><a name="vh9P-1690184532093"></a>内存中分为一个“固定区”和若干个“覆盖区”。需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束)不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p> 
         <p style="margin-left:0;"><a name="crKj-1690184487080"></a></p> 
         <p><img alt="" height="449" src="https://i-blog.csdnimg.cn/blog_migrate/0e5292c7b456c5feb553ec1f9fdaad46.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="6ClN-1690184495204"></a></p> 
         <p style="margin-left:0;"><a name="uZ0I-1690184493086"></a></p> 
         <p><img alt="" height="449" src="https://i-blog.csdnimg.cn/blog_migrate/f2e58f8c04ea96801bb60c6761997c56.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="1HJW-1690184455873"></a></p> 
         <p style="margin-left:0;"><a name="2kWS-1690184455875"></a>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点:对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</p> 
         <h5 style="margin-left:0;"><a name="ebiC-1690184455877"></a>2.交换技术</h5> 
         <p style="margin-left:0;"><a name="M1Xf-1690184455879"></a>交换（对换）技术的设计思想: 内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。之前讲的中级调度（内存调度）就是为这个服务的。</p> 
         <p style="margin-left:0;"><a name="BzNM-1690184605003"></a></p> 
         <p><img alt="" height="234" src="https://i-blog.csdnimg.cn/blog_migrate/1238d3fa8e132a2e5e118daa322cbb5a.png" width="914"></p> 
         <p style="margin-left:0;"><a name="ftcC-1690184455881"></a>1.应该在外存（磁盘）的什么位置保存被换出的进程?</p> 
         <p style="margin-left:0;"><a name="wHvl-1690184455883"></a>具有对换功能的操作系统中，通常把<strong>磁盘空间分为文件区和对换区两部分</strong>。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用<strong>连续分配</strong>方式（学过文件管理章节后即可理解）。总之，对换区的I/O速度比文件区的更快。</p> 
         <p style="margin-left:0;"><a name="oMCF-1690184455885"></a>2.什么时候应该交换?</p> 
         <p style="margin-left:0;"><a name="u65S-1690184455887"></a>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</p> 
         <p style="margin-left:0;"><a name="Rykv-1690184455889"></a>3.应该换出哪些进程?</p> 
         <p style="margin-left:0;"><a name="p6Ey-1690184455891"></a>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p> 
         <p style="margin-left:0;"><a name="hFi4-1690184455893"></a><strong>(注意:PCB会常驻内存，不会被换出外存)</strong></p> 
         <p style="margin-left:0;"><a name="as9I-1690184725845"></a></p> 
         <h4 style="margin-left:0;"><a name="H8mW-1690184713523"></a>4.连续分配管理方式</h4> 
         <p style="margin-left:0;"><a name="8TKI-1690184713760"></a>连续分配：指为用户进程分配的必须是<strong>一个连续的内存空间</strong>。</p> 
         <p style="margin-left:0;"><a name="btqy-1690184721460"></a></p> 
         <p><img alt="" height="267" src="https://i-blog.csdnimg.cn/blog_migrate/e6843556d3375ddc477ce46ee474b3dc.png" width="809"></p> 
         <h5 style="margin-left:0;"><a name="rRnJ-1690184713762"></a>1.单一连续分配</h5> 
         <ol>
          <li><a name="FObv-1690184713764"></a>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。</li>
          <li><a name="8EIR-1690184713766"></a>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。</li>
          <li><a name="FzV8-1690184713768"></a>优点: 实现简单 ;无外部碎片;可以采用覆盖技术扩充内存;不一定需要采取内存保护（eg:早期的 PC操作系统MS-DOS)。</li>
          <li><a name="i72f-1690184713770"></a>缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。</li>
         </ol> 
         <p style="margin-left:0;"><a name="8hyC-1690184764519"></a></p> 
         <p><img alt="" height="500" src="https://i-blog.csdnimg.cn/blog_migrate/b0903277d521f37fefc9deae5592f182.png" width="517"></p> 
         <h5 style="margin-left:0;"><a name="2l60-1690184764523"></a>2.固定分区分配</h5> 
         <p style="margin-left:0;"><a name="NXoG-1690184799579"></a></p> 
         <p><img alt="" height="566" src="https://i-blog.csdnimg.cn/blog_migrate/515da33a3a55a080039960ef457f2067.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="U8sf-1690184846595"></a></p> 
         <p><img alt="" height="525" src="https://i-blog.csdnimg.cn/blog_migrate/190caf9c60a7a58a5e3e33566480684d.png" width="1153"></p> 
         <h5 style="margin-left:0;"><a name="2MoP-1690184788740"></a>3.动态分区分配</h5> 
         <p style="margin-left:0;"><a name="m8ym-1690184788742"></a>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p> 
         <p style="margin-left:0;"><a name="T0ia-1690184788744"></a>使用这种方式的话，我们需要考虑以下三个问题。</p> 
         <ol>
          <li><a name="y3oA-1690184788746"></a> 系统要用什么样的数据结构记录内存的使用情况?</li>
         </ol> 
         <p style="margin-left:0;"><a name="FZWA-1690186264726"></a></p> 
         <p><img alt="" height="493" src="https://i-blog.csdnimg.cn/blog_migrate/a22098192cfce0169df7a022414f61af.png" width="1142"></p> 
         <ol>
          <li><a name="NNGo-1690184788749"></a> 当很多个空闲分区都能满足需求时,应该选择哪个分区进行分配?</li>
         </ol> 
         <p style="margin-left:0;"><a name="PN8f-1690184788751"></a>​ 使用动态分区算法，这个将在下一小节进行详细介绍。</p> 
         <ol>
          <li><a name="xCES-1690184788753"></a> 如何进行分区的分配与回收操作?</li>
         </ol> 
         <ol>
          <li><a name="cGa5-1690184788755"></a>如何分配 -----------&gt; 使用动态分区算法之后，修改数据结构即可。</li>
         </ol> 
         <p style="margin-left:0;"><a name="D5E1-1690187247737"></a></p> 
         <p><img alt="" height="459" src="https://i-blog.csdnimg.cn/blog_migrate/415e1a7c47507b1625702a9031c50058.png" width="1068"></p> 
         <ol>
          <li><a name="RknU-1690184788757"></a>如何回收-------------------------------&gt; 牢记一点即可，会把相邻的空闲区域合并为一个。</li>
         </ol> 
         <p style="margin-left:0;"><a name="8jwD-1690187384802"></a></p> 
         <p><img alt="" height="440" src="https://i-blog.csdnimg.cn/blog_migrate/c5ef8fed579076e445f5dc63f0cad0d8.png" width="1103"></p> 
         <ol>
          <li><a name="6JBr-1690184788759"></a> 内部碎片和外部碎片</li>
         </ol> 
         <ol>
          <li><a name="tAwA-1690184788761"></a>动态分区分配没有内部碎片，但是有外部碎片。</li>
          <li><a name="fB5o-1690184788763"></a><strong><span style="background-color:#a2e043;">内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。</span></strong></li>
          <li><a name="5AFM-1690184788765"></a><strong><span style="background-color:#a2e043;">外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</span></strong></li>
          <li><a name="jzTq-1690184788767"></a>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些进程“碎片”不能满足进程的需求。可以通过紧凑（(拼凑，Compaction)技术来解决外部碎片。</li>
         </ol> 
         <h4 style="margin-left:0;"><a name="2yEg-1690187552966"></a>5.动态分区分配算法</h4> 
         <p style="margin-left:0;"><a name="IcMG-1690187520941"></a>动态分区分配算法:在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?</p> 
         <h5 style="margin-left:0;"><a name="T0EJ-1690187549909"></a>1.首次适应算法</h5> 
         <p style="margin-left:0;"><a name="FiBu-1690187549911"></a>算法思想: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p> 
         <p style="margin-left:0;"><a name="EomG-1690187549913"></a>如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表），<strong>找到大小能满足要求的第一个空闲分区。</strong></p> 
         <p style="margin-left:0;"><a name="1mRj-1690187740775"></a></p> 
         <p><img alt="" height="388" src="https://i-blog.csdnimg.cn/blog_migrate/aeaec914df9c78acfad74611277a62df.png" width="1013"></p> 
         <h5 style="margin-left:0;"><a name="52Dn-1690187549915"></a>2.最佳适应算法</h5> 
         <p style="margin-left:0;"><a name="3otm-1690187549917"></a>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。</p> 
         <p style="margin-left:0;"><a name="H4om-1690187549919"></a>如何实现:<strong>空闲分区按容量递增次序链接。每次分配以后都要把最小的分区调到最前面。</strong>每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p> 
         <p style="margin-left:0;"><a name="GckO-1690187845242"></a></p> 
         <p><img alt="" height="346" src="https://i-blog.csdnimg.cn/blog_migrate/da4b7ec904abc7a7c5f85307c3261659.png" width="998"></p> 
         <h5 style="margin-left:0;"><a name="o19k-1690187549921"></a>3.最大适应算法</h5> 
         <p style="margin-left:0;"><a name="t2Zd-1690187549923"></a>又称最坏适应算法(Largest Fit)</p> 
         <p style="margin-left:0;"><a name="AXWM-1690187549925"></a>算法思想:为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时<strong>优先使用最大的连续空闲区</strong>，这样分配后剩余的空闲区就不会太小，更方便使用。</p> 
         <p style="margin-left:0;"><a name="YZMV-1690187549927"></a>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。</p> 
         <p style="margin-left:0;"><a name="njS8-1690187933985"></a></p> 
         <p><img alt="" height="356" src="https://i-blog.csdnimg.cn/blog_migrate/75df364919a37014c8146b93589a83a9.png" width="1013"></p> 
         <h5 style="margin-left:0;"><a name="jNPY-1690187549929"></a>4.临近适应算法</h5> 
         <p style="margin-left:0;"><a name="Hb2E-1690187549931"></a>算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果<strong>每次都从上次查找结束的位置开始检索</strong>，就能解决上述问题。</p> 
         <p style="margin-left:0;"><a name="uwmF-1690187549933"></a>如何实现:空闲分区以地址递增的顺序排列(可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p> 
         <p style="margin-left:0;"><a name="ohZF-1690187979183"></a></p> 
         <p><img alt="" height="1200" src="https://i-blog.csdnimg.cn/blog_migrate/9305a9ca4b46ab5793fa52625220383c.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="0ETI-1690187549935"></a>5.四种算法对比</h5> 
         <p style="margin-left:0;"><a name="MxEa-1690188004072"></a></p> 
         <p><img alt="" height="458" src="https://i-blog.csdnimg.cn/blog_migrate/739f84d66ac40c43fb4b81df7146bd36.png" width="932"></p> 
         <p style="margin-left:0;"><a name="2Kif-1690188004077"></a></p> 
         <h4 style="margin-left:0;"><a name="9v6Q-1690188008655"></a>6.基本分页存储管理</h4> 
         <p style="margin-left:0;"><a name="Qowg-1690188013040"></a>连续分配:为用户进程分配的必须是一个连续的内存空间。</p> 
         <p style="margin-left:0;"><a name="CewF-1690188013042"></a>非连续分配:为用户进程分配的可以是一些分散的内存空间。</p> 
         <p style="margin-left:0;"><a name="PVKN-1690188470570"></a></p> 
         <p style="margin-left:0;"><a name="ZEn6-1690188471229"></a></p> 
         <p><img alt="" height="220" src="https://i-blog.csdnimg.cn/blog_migrate/67b1d467050f1a7cb06c6f5470fe46c5.png" width="764"></p> 
         <p style="margin-left:0;"><a name="xdRm-1690188471233"></a><strong>基本分页存储管理的思想――把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分。</strong></p> 
         <p style="margin-left:0;"><a name="8bDq-1690188519361"></a>将<strong>内存空间</strong>分为一个个大小相等的分区（比如:每个分区4KB），<strong>每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”</strong>。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。</p> 
         <p style="margin-left:0;"><a name="GxcM-1690188519363"></a>将<strong>用户进程的地址空间</strong>也分为与页框大小相等的一个个区域，称为<strong>“页”或“页面”</strong>。每个页面也有一个编号，即“页号”，页号也是从0开始。</p> 
         <p style="margin-left:0;"><a name="Jgg2-1690188519365"></a>(注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片)</p> 
         <p style="margin-left:0;"><a name="k43J-1690188519367"></a>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p> 
         <p style="margin-left:0;"><a name="ztxm-1690188519369"></a><strong>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</strong></p> 
         <p style="margin-left:0;"><a name="5KG4-1690188519371"></a>思考： 将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换?</p> 
         <blockquote> 
          <ol>
           <li><a name="vllT-1690188519373"></a> 要算出逻辑地址对应的页号</li>
           <li><a name="jYOF-1690188519375"></a> 要知道该页号对应页面在内存中的起始地址</li>
           <li><a name="B5PU-1690188519377"></a> 要算出逻辑地址在页面内的“偏移量”</li>
           <li><a name="mROt-1690188519379"></a> 物理地址 = 页面始址＋页内偏移量</li>
          </ol> 
         </blockquote> 
         <p style="margin-left:0;"><a name="SM1m-1690188519381"></a>如何计算:</p> 
         <blockquote> 
          <ol>
           <li><a name="guZV-1690188519383"></a> 页号=逻辑地址/页面长度(<strong>取除法的整数部分</strong>)</li>
           <li><a name="y2wl-1690188519385"></a> 页内偏移量 = 逻辑地址%页面长度（<strong>取除法的余数部分</strong>)</li>
           <li><a name="HGPS-1690188519387"></a> 页面在内存中的起始位置:操作系统需要用某种数据结构记录进程各个页面的起始位置。</li>
          </ol> 
         </blockquote> 
         <p style="margin-left:0;"><a name="Njvr-1690188519389"></a>举例:</p> 
         <blockquote> 
          <p style="margin-left:0;"><a name="1tSo-1690188519392"></a>页号=80 / 50= 1</p> 
          <p style="margin-left:0;"><a name="P4QG-1690188519394"></a>页内偏移量=80 % 50 = 30</p> 
         </blockquote> 
         <p style="margin-left:0;"><a name="flTz-1690188519396"></a>1号页在内存中存放的起始位置450</p> 
         <p style="margin-left:0;"><a name="CTJm-1690188529318"></a></p> 
         <p><img alt="" height="614" src="https://i-blog.csdnimg.cn/blog_migrate/fd0b03ecad1a7ac9c894d1c2aebf4fe6.png" width="1134"></p> 
         <p style="margin-left:0;"><a name="PVhJ-1690188519398"></a>思考: 如何知道该页号对应页面在内存中的起始地址?</p> 
         <p style="margin-left:0;"><a name="325U-1690188519400"></a>操作系统为每一个进程创建一个页表</p> 
         <p style="margin-left:0;"><a name="JprT-1690188534162"></a></p> 
         <p><img alt="" height="434" src="https://i-blog.csdnimg.cn/blog_migrate/fa3b5f102ec444ff0eaf9f0452aacbdc.png" width="1089"></p> 
         <p style="margin-left:0;"><a name="9o0f-1690188519402"></a>如何理解每个页表项的长度是相同的，页号是“隐含的”？</p> 
         <p style="margin-left:0;"><a name="0Cny-1690188542322"></a></p> 
         <p><img alt="" height="482" src="https://i-blog.csdnimg.cn/blog_migrate/6111a1ec1d85cd98c7a30027bf75c288.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="l4oh-1690188542335"></a>7.基本地址变换机构</h4> 
         <p style="margin-left:0;"><a name="mR4J-1690198183821"></a>基本地址变换机构可以<strong>借助进程的页表将逻辑地址转换为物理地址</strong>。</p> 
         <p style="margin-left:0;"><a name="Fyfe-1690198183823"></a>通常会在系统中设置一个页表寄存器(PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p> 
         <ol>
          <li><a name="DQgy-1690198183825"></a>执行流程</li>
         </ol> 
         <p style="margin-left:0;"><a name="ocel-1690198194677"></a></p> 
         <p><img alt="" height="658" src="https://i-blog.csdnimg.cn/blog_migrate/659ab360d9b4aa6bc0143112b2a803b2.png" width="1197"></p> 
         <ol>
          <li><a name="dT1q-1690198183827"></a>页表项长度，页表长度，页面大小</li>
         </ol> 
         <p style="margin-left:0;"><a name="2rDU-1690198183830"></a>页表长度是指这个页表中总共有几个页表项，即总共有多少页。页面大小是指一个页面占多大的存储空间。页表项长度是指每个页表项占多大的存储空间。</p> 
         <p style="margin-left:0;"><a name="vLxa-1690198183832"></a>通过下面这个例子来理解页表项长度。</p> 
         <p style="margin-left:0;"><a name="BpjR-1690198183834"></a>Eg:假设某系统物理内存大小为4GB，页面大小为4KB，内存总共会被分为2^32/ 2^12=2^20个内存块，因此内存块号的范围应该是0~2^20 - 1。因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3个字节才够(每个字节8个二进制位，3个字节共24个二进制位)。每个块号用三个字节来表示。</p> 
         <p style="margin-left:0;"><a name="zMm9-1690198208696"></a></p> 
         <p style="margin-left:0;"><a name="vGKb-1690198209022"></a></p> 
         <p><img alt="" height="383" src="https://i-blog.csdnimg.cn/blog_migrate/090618ec7ff4acc1cbe38c90b6047039.png" width="431"></p> 
         <p style="margin-left:0;"><a name="JO6U-1690198209034"></a></p> 
         <h4 style="margin-left:0;"><a name="7koh-1690198803362"></a>8.具有快表的地址变换机构</h4> 
         <h5 style="margin-left:0;"><a name="p1Gi-1690198814585"></a>1.局部性原理</h5> 
         <p style="margin-left:0;"><a name="j6ho-1690198814587"></a><strong>时间局部性</strong>:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</p> 
         <p style="margin-left:0;"><a name="e1mW-1690198814589"></a><strong>空间局部性</strong>:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)</p> 
         <p style="margin-left:0;"><a name="n99m-1690198814591"></a>上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否利用这个特性减少访问页表的次数呢?</p> 
         <h5 style="margin-left:0;"><a name="4afU-1690198814593"></a>2.快表</h5> 
         <p style="margin-left:0;"><a name="nv8M-1690198814595"></a>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p> 
         <ol>
          <li><a name="XIZF-1690198814597"></a>执行流程</li>
         </ol> 
         <p style="margin-left:0;"><a name="EGPR-1690198998871"></a></p> 
         <p><img alt="" height="693" src="https://i-blog.csdnimg.cn/blog_migrate/911913ba56042c61609149816963280f.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="Fw0O-1690198814599"></a></h4> 
         <h4 style="margin-left:0;"><a name="8ljW-1690199058497"></a></h4> 
         <h4 style="margin-left:0;"><a name="9MhG-1690199058671"></a>9.两级页表</h4> 
         <p style="margin-left:0;"><a name="BfyJ-1690198814601"></a>两级页表的出现主要是为了解决单级页表的问题。那么单级页表有什么问题呢？</p> 
         <p style="margin-left:0;"><a name="ShL4-1690198814603"></a>问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p> 
         <p style="margin-left:0;"><a name="xu78-1690198814605"></a>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p> 
         <p style="margin-left:0;"><a name="3lo8-1690198814607"></a>1.解决问题一</p> 
         <p style="margin-left:0;"><a name="38ow-1690198814609"></a>我们可以回想以下当初是如何解决进程必须连续的问题 ？</p> 
         <p style="margin-left:0;"><a name="US5h-1690198814611"></a>我们可以把页表放在不同的页框中，再用一个表来记录各个各个子页表所在位置，我们把这个表叫做<strong>页目录表</strong>（外层页表，顶级页表）。</p> 
         <p style="margin-left:0;"><a name="Dbtk-1690199028131"></a></p> 
         <p><img alt="" height="617" src="https://i-blog.csdnimg.cn/blog_migrate/3f4898e80e591a573e19058cd1dbcaf7.png" width="1086"></p> 
         <p style="margin-left:0;"><a name="tPyo-1690198814614"></a>2.解决问题二</p> 
         <p style="margin-left:0;"><a name="Hbpl-1690199036935"></a></p> 
         <p><img alt="" height="434" src="https://i-blog.csdnimg.cn/blog_migrate/b5547e0bf442d7347f96b0cf6db4e347.png" width="1140"></p> 
         <p style="margin-left:0;"><a name="bqG1-1690198814616"></a>3. 其他细节</p> 
         <ol>
          <li><a name="9abz-1690198814618"></a> 若采用多级页表机制，则各级页表的大小不能超过一个页面</li>
         </ol> 
         <p style="margin-left:0;"><a name="peWq-1690343978996"></a>注意页表项是放在页面里面的一个结构，所以我们可以通过页面大小/页面项大小算出可以放多少个页表项</p> 
         <p style="margin-left:0;"><a name="xHzm-1690341218657"></a></p> 
         <p><img alt="" height="501" src="https://i-blog.csdnimg.cn/blog_migrate/488c22167daa4529d2c53166f6eaff25.png" width="1200"></p> 
         <ol>
          <li><a name="Ema0-1690198814620"></a> 两级页表的访存次数分析（假设没有快表机构）</li>
         </ol> 
         <ul>
          <li><a name="52rt-1690198814622"></a>第一次访存:访问内存中的页目录表</li>
          <li><a name="gmni-1690198814624"></a>第二次访存:访问内存中的二级页表</li>
          <li><a name="DSYx-1690198814626"></a>第三次访存:访问目标内存单元</li>
         </ul> 
         <p style="margin-left:0;"><a name="ChYV-1690198814628"></a>N级页表访问一个逻辑地址需要N+1次访问内存。</p> 
         <p style="margin-left:0;"><a name="2KRU-1690344095767"></a></p> 
         <h4 style="margin-left:0;"><a name="6dG7-1690344095945"></a>10.基本分段存储管理方式</h4> 
         <h5 style="margin-left:0;"><a name="erkd-1690344135720"></a>1.分段</h5> 
         <p style="margin-left:0;"><a name="qVnv-1690344135722"></a>进程的地址空间:<strong>按照程序自身的逻辑关系划分为若干个段</strong>，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，每段从0开始编址。</p> 
         <p style="margin-left:0;"><a name="AU58-1690344135724"></a>内存分配规则 : 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p> 
         <p style="margin-left:0;"><a name="Dg45-1690344204068"></a></p> 
         <p><img alt="" height="457" src="https://i-blog.csdnimg.cn/blog_migrate/86adc368338261aeec6f8bcc79fbd4e4.png" width="1200"></p> 
         <ol>
          <li><a name="orBa-1690344135726"></a>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。</li>
         </ol> 
         <p style="margin-left:0;"><a name="IfbJ-1690344489122"></a></p> 
         <p><img alt="" height="124" src="https://i-blog.csdnimg.cn/blog_migrate/f1896eed6dabeb8df9c74340a14a6259.png" width="897"></p> 
         <p style="margin-left:0;"><a name="p0Mp-1690344135728"></a><strong>段号的位数决定了每个进程最多可以分几个段。</strong></p> 
         <p style="margin-left:0;"><a name="qVLg-1690344135730"></a><strong>段内地址位数决定了每个段的最大长度是多少。</strong></p> 
         <h5 style="margin-left:0;"><a name="cQRo-1690344135732"></a>2.段表</h5> 
         <p style="margin-left:0;"><a name="rWJj-1690353518137"></a></p> 
         <p><img alt="" height="572" src="https://i-blog.csdnimg.cn/blog_migrate/e8bd0de625452beeee0a0b41c6ddd550.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="CquI-1690344135734"></a>3.段内寻址</h5> 
         <p style="margin-left:0;"><a name="R6bV-1690353645171"></a></p> 
         <p><img alt="" height="719" src="https://i-blog.csdnimg.cn/blog_migrate/16429b38631ac80ca20f590279286349.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="e1x3-1690344135736"></a>4.分段，分页对比</h5> 
         <ul>
          <li><a name="VxkK-1690344135738"></a>页是信息的物理单位。分页的主要目的是<strong>为了实现离散分配</strong>，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li>
          <li><a name="lseO-1690344135741"></a>段是信息的逻辑单位。分段的主要目的是<strong>更好地满足用户需求</strong>。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</li>
          <li><a name="E6NR-1690344135743"></a>页的<strong>大小固定</strong>且由系统决定。段的<strong>长度却不固定</strong>，决定于用户编写的程序。</li>
          <li><a name="Dhm5-1690344135745"></a>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</li>
          <li><a name="aUv5-1690344135747"></a>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li>
          <li><a name="vIVs-1690344135749"></a><strong>分段比分页更容易实现信息的共享和保护</strong></li>
         </ul> 
         <p style="margin-left:0;"><a name="1BBJ-1690355217377"></a></p> 
         <p><img alt="" height="788" src="https://i-blog.csdnimg.cn/blog_migrate/d9025c65cac4fb6eb3f5655ed6ddc182.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="wM6W-1690344135751"></a>11.段页式管理方式</h4> 
         <h5 style="margin-left:0;"><a name="yPQn-1690344135753"></a>1.分页，分段的优缺点</h5> 
         <p style="margin-left:0;"><a name="f7ZG-1690353935285"></a></p> 
         <p><img alt="" height="126" src="https://i-blog.csdnimg.cn/blog_migrate/8d8afa2e7a2f20ace7430df8f56dd5ba.png" width="788"></p> 
         <p style="margin-left:0;"><a name="V0BH-1690344135755"></a>既然两者都有优缺点，那么可不可以把他们结合起来呢？答案当然是可以的。如下图所示。</p> 
         <p style="margin-left:0;"><a name="w4vQ-1690355244303"></a></p> 
         <p><img alt="" height="419" src="https://i-blog.csdnimg.cn/blog_migrate/3c62169877033db711ff22542a165cdd.png" width="895"></p> 
         <h5 style="margin-left:0;"><a name="7ZBa-1690344135757"></a>2.段页式管理的逻辑结构</h5> 
         <p style="margin-left:0;"><a name="4Jsa-1690355284343"></a></p> 
         <p><img alt="" height="218" src="https://i-blog.csdnimg.cn/blog_migrate/9c562a4404dc60ce3bf9ba2e16ae789d.png" width="670"></p> 
         <p style="margin-left:0;"><a name="DeqX-1690344135759"></a>段号的位数决定了每个进程最多可以分几个段</p> 
         <p style="margin-left:0;"><a name="WmM6-1690344135761"></a>页号位数决定了每个段最大有多少页</p> 
         <p style="margin-left:0;"><a name="ZilG-1690344135763"></a>页内偏移量决定了页面大小、内存块大小是多少</p> 
         <h5 style="margin-left:0;"><a name="F8t5-1690344135765"></a>3.段内寻址</h5> 
         <p style="margin-left:0;"><a name="3Vgk-1690356503341"></a></p> 
         <p><img alt="" height="515" src="https://i-blog.csdnimg.cn/blog_migrate/10e40d9d6e8567b53f6426aaa65aebaf.png" width="1021"></p> 
         <h4 style="margin-left:0;"><a name="laHI-1690344135767"></a>12.虚拟内存</h4> 
         <h5 style="margin-left:0;"><a name="GmXb-1690344135769"></a>1.传统存储管理方式的特征和缺点</h5> 
         <ol>
          <li><a name="SgTW-1690344135771"></a><strong>一次性</strong>:作业<strong>必须一次性全部装入内存后才能开始运行</strong>。这会造成两个问题:①作业很大时，不能全部装入内存，导致大作业无法运行;②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li>
          <li><a name="9OO0-1690344135773"></a><strong>驻留性</strong>:一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。<strong>事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行</strong>，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li>
         </ol> 
         <p style="margin-left:0;"><a name="gLEf-1690356543391"></a></p> 
         <p><img alt="" height="334" src="https://i-blog.csdnimg.cn/blog_migrate/420af373d9b1251c1d600e85336b29a2.png" width="1106"></p> 
         <h5 style="margin-left:0;"><a name="mmM5-1690344135775"></a>2.虚拟内存的定义和特征</h5> 
         <ol>
          <li><a name="SgPv-1690344135777"></a>基于局部性原理（忘记的话，可以到第8节查看），在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</li>
          <li><a name="HGJU-1690344135779"></a>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</li>
          <li><a name="VVwp-1690344135781"></a>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</li>
          <li><a name="FfDo-1690344135783"></a>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</li>
         </ol> 
         <p style="margin-left:0;"><a name="5WNV-1690344135785"></a>易混知识点:</p> 
         <p style="margin-left:0;"><a name="Lv4H-1690344135787"></a><strong>虚拟内存的最大容量是由计算机的地址结构（ CPU寻址范围）确定的</strong></p> 
         <p style="margin-left:0;"><a name="ksk5-1690344135789"></a><strong>虚拟内存的实际容量= min(内存和外存容量之和，CPU寻址范围)</strong></p> 
         <p style="margin-left:0;"><a name="I6Gm-1690356879215"></a></p> 
         <p style="margin-left:0;"><a name="2Rgu-1690344135791"></a>如: 某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB.</p> 
         <p style="margin-left:0;"><a name="Q0ij-1690344135793"></a>则虚拟内存的最大容量为2^32B= 4GB 。 虚拟内存的实际容量=min (2^32B,512MB+2GB)= 2GB+512MB</p> 
         <p style="margin-left:0;"><a name="n4Mq-1690356881996"></a></p> 
         <p style="margin-left:0;"><a name="lcNB-1690344135795"></a>虚拟内存有一下三个主要特征:</p> 
         <ol>
          <li><a name="sBOe-1690344135797"></a>多次性:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>
          <li><a name="EE5n-1690344135799"></a>对换性:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li>
          <li><a name="P3wQ-1690344135801"></a>虚拟性:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>
         </ol> 
         <p style="margin-left:0;"><a name="dJND-1690344135803"></a>虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p> 
         <p style="margin-left:0;"><a name="7Jqm-1690356897576"></a></p> 
         <p><img alt="" height="222" src="https://i-blog.csdnimg.cn/blog_migrate/3c0d59895ee6f1cb6592142ed11f4dc6.png" width="1021"></p> 
         <h4 style="margin-left:0;"><a name="Dk2M-1690344135805"></a>13.请求分页管理方式</h4> 
         <h5 style="margin-left:0;"><a name="zyg4-1690344135807"></a>1.页表机制</h5> 
         <p style="margin-left:0;"><a name="m6jl-1690344135809"></a>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，</p> 
         <ol>
          <li><a name="VtOO-1690344135811"></a> 操作系统需要知道每个页面是否已经调入内存;</li>
          <li><a name="1r8W-1690344135813"></a> 如果还没调入，那么也需要知道该页面在外存中存放的位置。</li>
          <li><a name="7Zpj-1690344135815"></a> 当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;</li>
          <li><a name="a88D-1690344135817"></a> 有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</li>
         </ol> 
         <p style="margin-left:0;"><a name="7Ljh-1690344135819"></a>因此页表会增加四个字段来上面的信息。</p> 
         <p style="margin-left:0;"><a name="u6Op-1690356920600"></a></p> 
         <p><img alt="" height="372" src="https://i-blog.csdnimg.cn/blog_migrate/a38aa5f20ce98379c77174658e09a95e.png" width="1190"></p> 
         <h5 style="margin-left:0;"><a name="A8PF-1690344135821"></a>2.缺页中断机制</h5> 
         <p style="margin-left:0;"><a name="IClE-1690344135823"></a>假设此时要访问逻辑地址 = (页号，页内偏移量）= (0，1024)</p> 
         <p style="margin-left:0;"><a name="Nyfk-1690344135825"></a>在请求分页系统中，<strong>每当要访问的页面不在内存时，便产生一个缺页中断</strong>，然后由操作系统的缺页中断处理程序处理中断。</p> 
         <p style="margin-left:0;"><a name="sriK-1690344135827"></a>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p> 
         <p style="margin-left:0;"><a name="ucQO-1690344135829"></a>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p> 
         <p style="margin-left:0;"><a name="KRp3-1690344135831"></a>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p> 
         <p style="margin-left:0;"><a name="YqMB-1690344135833"></a>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p> 
         <p style="margin-left:0;"><a name="9dDl-1690344135835"></a>一条指令在执行期间，可能产生多次缺页中断。(如: copy AtoB，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p> 
         <p style="margin-left:0;"><a name="Xy1z-1690356995178"></a></p> 
         <p><img alt="" height="397" src="https://i-blog.csdnimg.cn/blog_migrate/99d73ed1b13ca1f65f6a295b810756d1.png" width="1114"></p> 
         <h5 style="margin-left:0;"><a name="lD56-1690344135837"></a>3.地址变换</h5> 
         <p style="margin-left:0;"><a name="6Ua7-1690357005642"></a></p> 
         <p><img alt="" height="691" src="https://i-blog.csdnimg.cn/blog_migrate/18dcf2fccffcddcfa411f6246198a537.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="xyhK-1690344135839"></a>4.补充知识点</h5> 
         <p style="margin-left:0;"><a name="Ztq7-1690344135841"></a>①<strong>只有“写指令”才需要修改“修改位”</strong>。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p> 
         <p style="margin-left:0;"><a name="sBnG-1690344135843"></a>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p> 
         <p style="margin-left:0;"><a name="jEqJ-1690344135845"></a>③需要用某种“页面置换算法”来决定一个换出页面（下节内容)</p> 
         <p style="margin-left:0;"><a name="fiNi-1690344135847"></a>④换入/换出页面都需要启动慢速的I/o操作，可见，如果换入/换出太频繁，会有很大的开销。</p> 
         <p style="margin-left:0;"><a name="7VU5-1690344135849"></a>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</p> 
         <h4 style="margin-left:0;"><a name="VfZH-1690344135852"></a>14.页面置换算法</h4> 
         <h5 style="margin-left:0;"><a name="jd2x-1690344135854"></a>1.最佳置换算法</h5> 
         <p style="margin-left:0;"><a name="f22P-1690344135856"></a>最佳置换算法（OPT，Optimal):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p> 
         <p style="margin-left:0;"><a name="BZD4-1690344135858"></a>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，<strong>最佳置换算法是无法实现的（在计算机的角度上）</strong>。</p> 
         <p style="margin-left:0;"><a name="cwGU-1690357041720"></a></p> 
         <p><img alt="" height="412" src="https://i-blog.csdnimg.cn/blog_migrate/94f9865dae40c1bfeb9f5d2a1b71bd37.png" width="1044"></p> 
         <h5 style="margin-left:0;"><a name="a5hZ-1690344135860"></a>2.先进先出置换算法</h5> 
         <p style="margin-left:0;"><a name="Ayeg-1690344135862"></a>先进先出置换算法（FIFO):每次选择淘汰的页面是最早进入内存的页面</p> 
         <p style="margin-left:0;"><a name="TXY9-1690344135864"></a>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p> 
         <p style="margin-left:0;"><a name="0KIr-1690344135866"></a>Belady异常―一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p> 
         <p style="margin-left:0;"><a name="bRtE-1690344135868"></a>只有FIFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。</p> 
         <p style="margin-left:0;"><a name="aT60-1690357068708"></a></p> 
         <p><img alt="" height="390" src="https://i-blog.csdnimg.cn/blog_migrate/8a8e13b83d9c4fc1d097cecb61cf5550.png" width="1028"></p> 
         <h5 style="margin-left:0;"><a name="eJOB-1690344135870"></a>3.最近最久未使用算法</h5> 
         <p style="margin-left:0;"><a name="4jAY-1690344135872"></a>最近最久未使用置换算法（LRU，least recently used):每次淘汰的页面是<strong>最近最久未使用</strong>的页面。</p> 
         <p style="margin-left:0;"><a name="DIwK-1690344135874"></a>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p> 
         <p style="margin-left:0;"><a name="DwLx-1690357080711"></a></p> 
         <p><img alt="" height="405" src="https://i-blog.csdnimg.cn/blog_migrate/558c6c2b4a941ca5a173fac83ee8ecee.png" width="1060"></p> 
         <h5 style="margin-left:0;"><a name="cMaF-1690344135876"></a>4.时钟置换算法</h5> 
         <p style="margin-left:0;"><a name="L6vW-1690344135878"></a>最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差;最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p> 
         <p style="margin-left:0;"><a name="eNoN-1690344135880"></a>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，NotRecently Used)</p> 
         <p style="margin-left:0;"><a name="FKXb-1690344135882"></a>简单的CLOCK 算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</p> 
         <p style="margin-left:0;"><a name="Ls1f-1690357107734"></a></p> 
         <p><img alt="" height="317" src="https://i-blog.csdnimg.cn/blog_migrate/dbdb76418232825c77a9c0a85b12b2af.png" width="1031"></p> 
         <h5 style="margin-left:0;"><a name="eHhr-1690344135884"></a>5.改进型的时钟置换算法</h5> 
         <p style="margin-left:0;"><a name="iqEz-1690344135886"></a>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/o操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p> 
         <p style="margin-left:0;"><a name="Wvf1-1690344135888"></a>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/o操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。</p> 
         <p style="margin-left:0;"><a name="M7Ep-1690344135890"></a>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1)表示一个页面近期被访问过，且被修改过。</p> 
         <p style="margin-left:0;"><a name="av9f-1690344135892"></a>算法规则: 将所有可能被置换的页面排成一个循环队列</p> 
         <p style="margin-left:0;"><a name="S6x8-1690344135894"></a>第一轮:从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</p> 
         <p style="margin-left:0;"><a name="prWE-1690344135896"></a>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0</p> 
         <p style="margin-left:0;"><a name="bFzg-1690344135898"></a>第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0，0）的帧用于替换。本轮扫描不修改任何标志位</p> 
         <p style="margin-left:0;"><a name="AqhF-1690344135900"></a>第四轮:若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</p> 
         <p style="margin-left:0;"><a name="fKGb-1690344135902"></a>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</p> 
         <p style="margin-left:0;"><a name="FUbb-1690357116749"></a></p> 
         <p><img alt="" height="274" src="https://i-blog.csdnimg.cn/blog_migrate/66c18f28efa5eff422f553c0ddb18776.png" width="364"></p> 
         <h5 style="margin-left:0;"><a name="60Dt-1690344135904"></a>6.五种算法对比</h5> 
         <p style="margin-left:0;"><a name="WWLR-1690357122748"></a></p> 
         <p><img alt="" height="445" src="https://i-blog.csdnimg.cn/blog_migrate/74349526dd5cbe5f271d6f78a50b4a23.png" width="877"></p> 
         <h4 style="margin-left:0;"><a name="bC8z-1690344135906"></a>15.页面分配策略</h4> 
         <h5 style="margin-left:0;"><a name="HFHJ-1690344135908"></a>1.页面分配，置换策略</h5> 
         <p style="margin-left:0;"><a name="yvJL-1690344135910"></a><strong>驻留集:指请求分页存储管理中给进程分配的物理块的集合。</strong></p> 
         <p style="margin-left:0;"><a name="HiNl-1690344135912"></a>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p> 
         <p style="margin-left:0;"><a name="ZxA0-1690344135914"></a>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际上用于进程推进的时间很少。</p> 
         <p style="margin-left:0;"><a name="i9jG-1690344135916"></a>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p> 
         <ol>
          <li><a name="hDZY-1690344135918"></a>固定分配:操作系统为每个进程分配一组固定数目的物理块，在进程运行期间大小不变。即，驻留集大小不变。</li>
          <li><a name="ZyBn-1690344135920"></a>可变分配:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</li>
          <li><a name="8SOM-1690344135922"></a>局部置换:发生缺页时只能选进程自己的物理块进行置换。</li>
          <li><a name="NiSn-1690344135924"></a>全局置换:可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li>
         </ol> 
         <p style="margin-left:0;"><a name="zGtS-1690344135926"></a>下面来分别介绍这几种方式。</p> 
         <ol>
          <li><a name="0LJb-1690344135928"></a>固定分配局部置换:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)</li>
          <li><a name="VvVM-1690344135930"></a>可变分配全局置换:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，<strong>只要某进程发生缺页都将获的物理块</strong>，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是进程中任意一个进程的页，因此被选中的这个进程物理块会减少，缺页率会增加。</li>
          <li><a name="Kjaf-1690344135932"></a>可变分配局部置换： 刚开始会为每个进程分配一定数量的物理块，当某进程发生缺页时，只允许从该进程自己的物理块中选出一个换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当，反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li>
         </ol> 
         <p style="margin-left:0;"><a name="mB9D-1690344135934"></a>可变分配全局置换:只要缺页就给分配新物理块</p> 
         <p style="margin-left:0;"><a name="2C7x-1690344135936"></a>可变分配局部置换:要根据发生缺页的频率来动态地增加或减少进程的物理块</p> 
         <h5 style="margin-left:0;"><a name="X52A-1690344135938"></a>2.何时调入页面</h5> 
         <p style="margin-left:0;"><a name="z5Mq-1690344135940"></a>1．预调页策略:根据局部性原理（主要是空间局部性），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。<strong>它是运行前调入。</strong></p> 
         <p style="margin-left:0;"><a name="o9Bj-1690344135942"></a>2．请求调页策略:进程在运行期间<strong>发现缺页时才将所缺页面调入内存</strong>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘l/o操作，因此I/o开销较大。<strong>它是运行时调入。</strong></p> 
         <h5 style="margin-left:0;"><a name="hAec-1690344135944"></a>3.从何处调入页面</h5> 
         <ol>
          <li><a name="q0pC-1690344135946"></a> 系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li>
         </ol> 
         <p style="margin-left:0;"><a name="a0Sh-1690357471999"></a></p> 
         <p><img alt="" height="437" src="https://i-blog.csdnimg.cn/blog_migrate/a70f6a8b74633654c9fd7d91083e79b9.png" width="541"></p> 
         <ol>
          <li><a name="jOmS-1690344135948"></a> 系统缺少足够的对换区空间:凡是不<strong>会被修改的数据都直接从文件区调入</strong>，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，<strong>换出时需写回磁盘对换区</strong>，下次需要时再从对换区调入。</li>
         </ol> 
         <p style="margin-left:0;"><a name="aj9u-1690357491442"></a></p> 
         <p><img alt="" height="440" src="https://i-blog.csdnimg.cn/blog_migrate/7253667d7987d3769a47c17c7ced36da.png" width="521"></p> 
         <ol>
          <li><a name="SOis-1690344135950"></a> UNIX方式:运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li>
         </ol> 
         <p style="margin-left:0;"><a name="m4ox-1690357539070"></a></p> 
         <p><img alt="" height="422" src="https://i-blog.csdnimg.cn/blog_migrate/69f1a19b4508fba8053d75112ec714e7.png" width="511"></p> 
         <h5 style="margin-left:0;"><a name="jyTh-1690344135952"></a>4.抖动（颠簸）现象，工作集</h5> 
         <p style="margin-left:0;"><a name="xndE-1690344135954"></a>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的<strong>物理块数</strong>（分配给进程的物理块不够)。</p> 
         <p style="margin-left:0;"><a name="UMiN-1690344135957"></a>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p> 
         <p style="margin-left:0;"><a name="2KQI-1690344135959"></a>为了研究为应该为每个进程分配多少个物理块，Denning提出了进程“工作集”的概念。</p> 
         <p style="margin-left:0;"><a name="iKDR-1690344135961"></a>驻留集:指请求分页存储管理中给进程分配的内存块的集合。</p> 
         <p style="margin-left:0;"><a name="giyZ-1690344135963"></a><strong>工作集:指在某段时间间隔里，进程实际访问页面的集合。</strong></p> 
         <p style="margin-left:0;"><a name="dp30-1690344135965"></a>一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。</p> 
         <p style="margin-left:0;"><a name="2zGG-1690357564105"></a></p> 
         <p><img alt="" height="191" src="https://i-blog.csdnimg.cn/blog_migrate/1f7adfd5e2c8abd868b513b49c96ca42.png" width="647"></p> 
         <h2 style="margin-left:0;"><a name="wY8q-1690357564110"></a>四、文件系统</h2> 
         <h4 style="margin-left:0;"><a name="WRoR-1690357580959"></a>1.文件管理</h4> 
         <ol>
          <li><a name="Ne6v-1690543603971"></a>文件――就是一组有意义的信息/数据集合。</li>
          <li><a name="iLSs-1690543616554"></a>一个文件有哪些属性？</li>
         </ol> 
         <p style="margin-left:0;"><a name="hBun-1690543926430"></a></p> 
         <p><img alt="" height="690" src="https://i-blog.csdnimg.cn/blog_migrate/0bb6dbd0934db5757f1a869936e397fa.png" width="636"></p> 
         <ol>
          <li><a name="BsqF-1690543616556"></a> 文件名:由创建文件的用户决定文件名，主要是为了方便用户找到文件，<strong>同一目录下不允许有重名文件。</strong></li>
         </ol> 
         <p style="margin-left:0;"><a name="c5T3-1690543807405"></a></p> 
         <p><img alt="" height="665" src="https://i-blog.csdnimg.cn/blog_migrate/3db31f3a697511f006de0e4c8faa9291.png" width="1080"></p> 
         <ol>
          <li><a name="HbU8-1690543616558"></a> 标识符:一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li>
          <li><a name="iVBh-1690543616560"></a> 类型:指明文件的类型</li>
          <li><a name="JJYW-1690543616562"></a> 位置:文件存放的路径（让用户使用)、在外存中的地址(操作系统使用，对用户不可见)</li>
          <li><a name="CJmD-1690543616564"></a> 大小:指明文件大小创建时间、上次修改时间文件所有者信息</li>
          <li><a name="dMOn-1690543616566"></a> 保护信息:对文件进行保护的访问控制信息</li>
         </ol> 
         <p style="margin-left:0;"><a name="vsdO-1690543616568"></a>文件分为有结构文件和无结构文件。</p> 
         <p style="margin-left:0;"><a name="9x8q-1690543624354"></a></p> 
         <p><img alt="" height="430" src="https://i-blog.csdnimg.cn/blog_migrate/47473ab934056233b5c1687ab6c08133.png" width="1115"></p> 
         <p style="margin-left:0;"><a name="QGvJ-1690543616570"></a>操作系统向上（用户和应用程序）提供的功能</p> 
         <p style="margin-left:0;"><a name="OTbV-1690543629697"></a></p> 
         <p><img alt="" height="456" src="https://i-blog.csdnimg.cn/blog_migrate/be2313e90f1006bb1bf2c8292f56f1c0.png" width="1110"></p> 
         <h4 style="margin-left:0;"><a name="E0eA-1690357622746"></a>2.文件的逻辑结构</h4> 
         <p style="margin-left:0;"><a name="iuY9-1690543982485"></a></p> 
         <p><img alt="" height="287" src="https://i-blog.csdnimg.cn/blog_migrate/566fbd9c3865abeb8a56f738d1c83171.png" width="1122"></p> 
         <p style="margin-left:0;"><a name="G4RZ-1690543998874"></a>按文件是否有结构分类，可以分为<strong>无结构文件、有结构文件</strong>两种。</p> 
         <p style="margin-left:0;"><a name="oFuW-1690544046463"></a>无结构文件:<strong>文件内部的数据就是一系列二进制流或字符流组成。</strong>又称“流式文件”。如:Windows操作系统中的.txt文件。</p> 
         <p style="margin-left:0;"><a name="S7lq-1690547202685"></a></p> 
         <p><img alt="" height="179" src="https://i-blog.csdnimg.cn/blog_migrate/e7e63660837d181f8c166941350212f5.png" width="470"></p> 
         <p style="margin-left:0;"><a name="2ubz-1690544046465"></a>有结构文件:由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID)</p> 
         <p style="margin-left:0;"><a name="eSkc-1690544046467"></a>我们主要研究有结构文件。</p> 
         <p style="margin-left:0;"><a name="YZfj-1690544057570"></a></p> 
         <p><img alt="" height="270" src="https://i-blog.csdnimg.cn/blog_migrate/c65b4b7cbbedf7dec135fcf0d3d912d8.png" width="917"></p> 
         <h5 style="margin-left:0;"><a name="FoDe-1690544046469"></a>1.顺序文件</h5> 
         <p style="margin-left:0;"><a name="rDqT-1690544046471"></a>顺序文件:文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储（相当于数组）或链式存储（相当于链表）。</p> 
         <p style="margin-left:0;"><a name="ELd1-1690544046473"></a>顺序存储又可以分为串结构和顺序结构。</p> 
         <p style="margin-left:0;"><a name="aBJ0-1690544071576"></a></p> 
         <p><img alt="" height="141" src="https://i-blog.csdnimg.cn/blog_migrate/eb5061ed6e1f6bfc86f223fcb4cbf73d.png" width="944"></p> 
         <p style="margin-left:0;"><a name="nSsw-1690544046475"></a>那么这几种存储方式可以快速找到第i个记录对应的地址呢？</p> 
         <p style="margin-left:0;"><a name="rrnf-1690544078583"></a></p> 
         <p><img alt="" height="280" src="https://i-blog.csdnimg.cn/blog_migrate/1e932590a63419b5ffb9b3fd385a4f47.png" width="1136"></p> 
         <p style="margin-left:0;"><a name="J2Zk-1690544046477"></a>结论:定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取;若能再保证记录的顺序结构，则可实现快速检索(即根据关键字快速找到对应记录)</p> 
         <h5 style="margin-left:0;"><a name="wpVs-1690544046479"></a>2.索引文件</h5> 
         <p style="margin-left:0;"><a name="SErz-1690547773779"></a>简单的说也就是在顺序表的基础上加上一个指针可以直接指向不定长的顺序表。</p> 
         <p style="margin-left:0;"><a name="mE42-1690544046481"></a>思考：对于可变长记录文件，要找到第i个记录，必须先顺序第查找前i-1个记录,但是很多应用场景中又必须使用可变长记录。如何解决这个问题?</p> 
         <p style="margin-left:0;"><a name="ad6D-1690544046483"></a>这时我们可以建立一张索引表来快速找到第i个记录。如图所示：</p> 
         <p style="margin-left:0;"><a name="vZ2X-1690544085070"></a></p> 
         <p><img alt="" height="407" src="https://i-blog.csdnimg.cn/blog_migrate/23ff086a19e0fad54ff5dd3051ff5751.png" width="529"></p> 
         <p style="margin-left:0;"><a name="iDWL-1690544046485"></a><strong>索引表本身是定长记录的顺序文件。</strong>因此可以快速找到第i个记录对应的索引项。</p> 
         <p style="margin-left:0;"><a name="bCvO-1690544046487"></a>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。</p> 
         <p style="margin-left:0;"><a name="dEMu-1690544046489"></a>每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p> 
         <p style="margin-left:0;"><a name="jp4A-1690544046491"></a>另外，可以用不同的数据项建立多个索引表。如:学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。(Eg: SQL就支持根据某个数据项建立索引的功能)</p> 
         <h5 style="margin-left:0;"><a name="PA2D-1690544046493"></a>3.索引顺序文件</h5> 
         <p style="margin-left:0;"><a name="nH21-1690544046495"></a>思考索引文件的缺点:每个记录对应一个索引表项，因此索引表可能会很大。比如:文件的每个记录平均只占8字节，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p> 
         <p style="margin-left:0;"><a name="cD72-1690544046498"></a>那么如何解决呢？</p> 
         <p style="margin-left:0;"><a name="ohVU-1690544046500"></a>我们可以建立一个索引顺序文件。</p> 
         <p style="margin-left:0;"><a name="jO8e-1690544046502"></a>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是:并不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项。</strong></p> 
         <p style="margin-left:0;"><a name="rJkj-1690544046504"></a>在本例中，学生记录按照学生姓名的开头字母进行分组。<strong>每个分组就是一个顺序文件</strong>，分组内的记录不需要按关键字排序。</p> 
         <p style="margin-left:0;"><a name="cICe-1690544097598"></a></p> 
         <p><img alt="" height="404" src="https://i-blog.csdnimg.cn/blog_migrate/32cc56cabeeffabb778b10af107652ff.png" width="562"></p> 
         <h5 style="margin-left:0;"><a name="ExTH-1690544046506"></a>4.多级索引顺序文件</h5> 
         <p style="margin-left:0;"><a name="U78G-1690544046508"></a>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p> 
         <p style="margin-left:0;"><a name="DpDg-1690544046510"></a>例如，对于一个含10^6个记录的文件，可先为该文件建立一张低级索引表，每100个记录为一组，故低级索引表中共有10000个表项(即10000个定长记录)，再把这10000个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有100个表项。</p> 
         <p style="margin-left:0;"><a name="iqBQ-1690544104633"></a></p> 
         <p><img alt="" height="470" src="https://i-blog.csdnimg.cn/blog_migrate/62dc7aa1095e5b11bfc114f5fbddc225.png" width="1092"></p> 
         <h4 style="margin-left:0;"><a name="zUJ2-1690543998147"></a>3.文件目录</h4> 
         <p style="margin-left:0;"><a name="mktZ-1690547975953"></a></p> 
         <p><img alt="" height="375" src="https://i-blog.csdnimg.cn/blog_migrate/b794dd2ca0372136ddf422e209d252cb.png" width="962"></p> 
         <ol>
          <li><a name="OMRE-1690357649292"></a>目录本身就是一种有结构文件，由一条条记录组成。每条记录对应一个在该放在该目录下的文件。如图所示</li>
         </ol> 
         <p style="margin-left:0;"><a name="NDfm-1690548018027"></a></p> 
         <p><img alt="" height="501" src="https://i-blog.csdnimg.cn/blog_migrate/def917538642dcec0bd9089a75ad29f1.png" width="1074"></p> 
         <h5 style="margin-left:0;"><a name="xcbv-1690548005909"></a>1.文件控制块（FCB）</h5> 
         <ol>
          <li><a name="eGPt-1690548005911"></a>目录文件中的一条记录就是一个“文件控制块（FCB)</li>
         </ol> 
         <p style="margin-left:0;"><a name="xLDb-1690548005913"></a>FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。</p> 
         <p style="margin-left:0;"><a name="P4A7-1690548005915"></a>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等)，使用信息（如文件的建立时间、修改时间等）。</p> 
         <p style="margin-left:0;"><a name="mTAJ-1690548005917"></a>最重要，最基本的还是文件名、文件存放的物理地址。</p> 
         <h5 style="margin-left:0;"><a name="KeUd-1690548005919"></a>2.单级目录结构</h5> 
         <p style="margin-left:0;"><a name="UH4F-1690548227714"></a></p> 
         <p><img alt="" height="471" src="https://i-blog.csdnimg.cn/blog_migrate/c3581d6e6bd7f8c0cc85b6e53011b16c.png" width="1049"></p> 
         <h5 style="margin-left:0;"><a name="bdB5-1690548005921"></a>3.二级目录结构</h5> 
         <p style="margin-left:0;"><a name="vtnn-1690548250085"></a></p> 
         <p><img alt="" height="553" src="https://i-blog.csdnimg.cn/blog_migrate/d4d5f8e08bb7f080d20fd16b36729f7a.png" width="1176"></p> 
         <h5 style="margin-left:0;"><a name="zg4E-1690548005923"></a>4.多级目录结构（树形目录结构）</h5> 
         <p style="margin-left:0;"><a name="T9ii-1690548346125"></a></p> 
         <p><img alt="" height="291" src="https://i-blog.csdnimg.cn/blog_migrate/a77dd1287f515a8eb290d49e9dd4d974.png" width="1091"></p> 
         <p style="margin-left:0;"><a name="P2Dz-1690548005925"></a>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p> 
         <h5 style="margin-left:0;"><a name="maWc-1690548005927"></a>5.无环图目录结构</h5> 
         <p style="margin-left:0;"><a name="0OMY-1690548366985"></a></p> 
         <p><img alt="" height="345" src="https://i-blog.csdnimg.cn/blog_migrate/e2218e5353b1ae199a5c984450301594.png" width="1097"></p> 
         <p style="margin-left:0;"><a name="5QZm-1690548005930"></a>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录(共享同一目录下的所有内容）。</p> 
         <p style="margin-left:0;"><a name="CAhD-1690548005932"></a>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。</p> 
         <p style="margin-left:0;"><a name="DOQR-1690548005934"></a>只有共享计数器减为0时，才删除结点。</p> 
         <p style="margin-left:0;"><a name="ZfdI-1690548005936"></a>注意:共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</p> 
         <h5 style="margin-left:0;"><a name="OO15-1690548005938"></a>6.索引结点（对FCB的改进）</h5> 
         <p style="margin-left:0;"><a name="iE0A-1690548371151"></a></p> 
         <p><img alt="" height="369" src="https://i-blog.csdnimg.cn/blog_migrate/c3376ea6c8e62de5230f81369c27d504.png" width="823"></p> 
         <p style="margin-left:0;"><a name="9p2d-1690548005940"></a>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p> 
         <p style="margin-left:0;"><a name="fjAW-1690548005942"></a>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。相比之下内存索引结点中需要增加一些信息，比如:文件是否被修改、此时有几个进程正在访问该文件等。</p> 
         <h4 style="margin-left:0;"><a name="Ip6B-1690547986290"></a>4.文件分配方式</h4> 
         <p style="margin-left:0;"><a name="hucZ-1690548505871"></a></p> 
         <p style="margin-left:0;"><a name="Q2lM-1690548515235"></a></p> 
         <p><img alt="" height="369" src="https://i-blog.csdnimg.cn/blog_migrate/6c9972ee0f3eff1fb98bc28b6bd14179.png" width="823"></p> 
         <p style="margin-left:0;"><a name="XOIy-1690548528092"></a></p> 
         <p style="margin-left:0;"><a name="dooO-1690548528559"></a>在介绍这些分配方式之前，先介绍一下什么是文件块，磁盘块。</p> 
         <p style="margin-left:0;"><a name="dzfx-1690548546456"></a>在内存管理中，进程的逻辑地址空间被分为一个一个页面。</p> 
         <p style="margin-left:0;"><a name="V81B-1690548546458"></a>同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p> 
         <p style="margin-left:0;"><a name="PxTB-1690548546460"></a>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p> 
         <p style="margin-left:0;"><a name="4yO2-1690548546462"></a><strong>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。</strong></p> 
         <p style="margin-left:0;"><a name="Yq8g-1690548631420"></a></p> 
         <p><img alt="" height="638" src="https://i-blog.csdnimg.cn/blog_migrate/55ce928acc21571f59f4f3842f3df787.png" width="1107"></p> 
         <h5 style="margin-left:0;"><a name="lfhn-1690548546464"></a>1.连续分配</h5> 
         <p style="margin-left:0;"><a name="pknV-1690548546466"></a>连续分配方式要求每个文件在磁盘上占有一组连续的块。如图所示</p> 
         <p style="margin-left:0;"><a name="HJiY-1690548546468"></a>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB)</p> 
         <p style="margin-left:0;"><a name="S1xO-1690548546470"></a><strong>物理块号=起始块号＋逻辑块号（类似内存的页面的计算就好了）</strong></p> 
         <p style="margin-left:0;"><a name="l7Tv-1690548546472"></a>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号≥长度就不合法)、</p> 
         <p style="margin-left:0;"><a name="Sraf-1690548546474"></a>优点:支持顺序访问和直接访问（即随机访问)；<strong>连续分配的文件在顺序访问时速度最快</strong></p> 
         <p style="margin-left:0;"><a name="qtE5-1690548546476"></a>缺点:不方便文件拓展;存储空间利用率低，会产生磁盘碎片</p> 
         <p style="margin-left:0;"><a name="fz7q-1690548678449"></a></p> 
         <p><img alt="" height="484" src="https://i-blog.csdnimg.cn/blog_migrate/7179c222fa74966669e6241c756a4bae.png" width="619"></p> 
         <h5 style="margin-left:0;"><a name="y2tK-1690548546478"></a>2.链接分配——隐式链接</h5> 
         <p style="margin-left:0;"><a name="w5e9-1690548546480"></a>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p> 
         <ol>
          <li><a name="EXsd-1690548546482"></a>从逻辑块号到物理块号的转变</li>
         </ol> 
         <p style="margin-left:0;"><a name="bfNI-1690548546484"></a>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB)</p> 
         <p style="margin-left:0;"><a name="DH7N-1690548546486"></a>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置…以此类推。</p> 
         <p style="margin-left:0;"><a name="nD5i-1690548546489"></a>因此，读入i号逻辑块，总共需要i+1次磁盘l/O。</p> 
         <p style="margin-left:0;"><a name="uv5n-1690548546491"></a>结论:采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p> 
         <p style="margin-left:0;"><a name="hNbY-1690548946496"></a></p> 
         <p><img alt="" height="522" src="https://i-blog.csdnimg.cn/blog_migrate/910539b4f46170aa81951c77d6408609.png" width="599"></p> 
         <h5 style="margin-left:0;"><a name="RBRM-1690548546493"></a>3.链接分配——显式链接</h5> 
         <p style="margin-left:0;"><a name="LkSI-1690548546495"></a>把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table)。如图所示</p> 
         <p style="margin-left:0;"><a name="VwUv-1690548546497"></a>注意:一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。</p> 
         <ol>
          <li><a name="ZObj-1690548546499"></a>从逻辑块号到物理块号的转变</li>
         </ol> 
         <p style="margin-left:0;"><a name="pFIi-1690548546501"></a>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项( FCB)</p> 
         <p style="margin-left:0;"><a name="4qGh-1690548546503"></a>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作。</p> 
         <p style="margin-left:0;"><a name="BcUO-1690548546505"></a>结论:采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的 0~i-1号逻辑块)，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p> 
         <p style="margin-left:0;"><a name="xK3C-1690548546507"></a>显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p> 
         <p style="margin-left:0;"><a name="cy3y-1690549009195"></a></p> 
         <p><img alt="" height="520" src="https://i-blog.csdnimg.cn/blog_migrate/837ed30ea4f0483dc5ce502a1e97425e.png" width="633"></p> 
         <h5 style="margin-left:0;"><a name="YE3W-1690548546509"></a>4.两种链接分配方式总结</h5> 
         <p style="margin-left:0;"><a name="UikC-1690549476816"></a>最大的区别就是一个是有一个单独的表，一个是用指针的方式</p> 
         <p style="margin-left:0;"><a name="rQ3c-1690548546511"></a>隐式链接――除文件的最后一个盘块之外，<strong>每个盘块中都存有指向下一个盘块的指针</strong>。文件目录包括文件第一块的指针和最后一块的指针。</p> 
         <ol>
          <li><a name="yGEg-1690548546513"></a>优点:很方便文件拓展，不会有碎片问题，外存利用率高。</li>
          <li><a name="KAtT-1690548546515"></a>缺点:只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li>
         </ol> 
         <p style="margin-left:0;"><a name="WANL-1690548546517"></a>显式链接――把用于<strong>链接文件各物理块的指针显式地存放在一张表中</strong>，即文件分配表（FAT，FileAllocation Table)。<strong>一个磁盘只会建立一张文件分配表</strong>。开机时文件分配表放入内存，并常驻内存。</p> 
         <ol>
          <li><a name="nHzM-1690548546519"></a>优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li>
          <li><a name="WiQh-1690548546521"></a>缺点:文件分配表的需要占用一定的存储空间。</li>
         </ol> 
         <h5 style="margin-left:0;"><a name="q8ll-1690548546523"></a>5.索引分配</h5> 
         <p style="margin-left:0;"><a name="WXzh-1690548546525"></a>索引分配允许文件<strong>离散地分配在各个磁盘块</strong>中，<strong>系统会为每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p> 
         <ol>
          <li><a name="5ZOL-1690548546527"></a>从逻辑块号到物理块号的转变</li>
         </ol> 
         <p style="margin-left:0;"><a name="QoWk-1690548546529"></a>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项（FCB)</p> 
         <p style="margin-left:0;"><a name="Gi0x-1690548546531"></a>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的存放位置。</p> 
         <p style="margin-left:0;"><a name="j5S2-1690548546533"></a>可见，索引分配方式可以支持随机访问。<strong>文件拓展也很容易实现(只需要给文件分配一个空闲块，并增加一个索引表项即可)</strong></p> 
         <p style="margin-left:0;"><a name="OT2Z-1690548546535"></a>但是索引表需要占用一定的存储空间</p> 
         <p style="margin-left:0;"><a name="7dR6-1690549570815"></a></p> 
         <p><img alt="" height="443" src="https://i-blog.csdnimg.cn/blog_migrate/cbafbd402ca0d7f56a76558ce9cc3bdf.png" width="626"></p> 
         <p style="margin-left:0;"><a name="UHHG-1690548546537"></a>如果一个文件的索引表太大，一个磁盘块放不下，那么如何解决呢？</p> 
         <p style="margin-left:0;"><a name="exMH-1690548546539"></a>可以用以下三种方式解决。</p> 
         <p style="margin-left:0;"><a name="U6yN-1690548546541"></a>①链接方案:如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p> 
         <p style="margin-left:0;"><a name="SrLf-1690549875925"></a></p> 
         <p><img alt="" height="495" src="https://i-blog.csdnimg.cn/blog_migrate/14690d789c47b0cd408011d612ba1a74.png" width="626"></p> 
         <p style="margin-left:0;"><a name="nAYN-1690548546543"></a>②多层索引:建立多层索引（原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p> 
         <p style="margin-left:0;"><a name="Uuil-1690549888918"></a></p> 
         <p><img alt="" height="487" src="https://i-blog.csdnimg.cn/blog_migrate/d8196b0bd3d51aecc6eec97d8abff909.png" width="550"></p> 
         <p style="margin-left:0;"><a name="M9gx-1690548546545"></a>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表)。</p> 
         <p style="margin-left:0;"><a name="BmMG-1690549900041"></a></p> 
         <p><img alt="" height="493" src="https://i-blog.csdnimg.cn/blog_migrate/6970efdd86b4a5a8a6d48cfd21835f33.png" width="1051"></p> 
         <p style="margin-left:0;"><a name="T0dS-1690548546547"></a>总结</p> 
         <p style="margin-left:0;"><a name="pkIF-1690548546549"></a>①链接方案 : 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。缺点:若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须先依次读入0~i-1号索引块，这就导致磁盘I/O次数过多，查找效率低下。</p> 
         <p style="margin-left:0;"><a name="D7CZ-1690548546551"></a>②多层索引:建立多层索引(原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作。缺点:即使是小文件，访问一个数据块依然需要K+1次读磁盘。</p> 
         <p style="margin-left:0;"><a name="24at-1690548546553"></a>③混合索引:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引(指向两层索引表)。优点:对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p> 
         <h5 style="margin-left:0;"><a name="EYkA-1690548546555"></a>6.三种分配方式总结</h5> 
         <p style="margin-left:0;"><a name="nNpr-1690549922945"></a></p> 
         <p><img alt="" height="438" src="https://i-blog.csdnimg.cn/blog_migrate/f0e72330e922d26801af36780d2a2f63.png" width="1009"></p> 
         <h4 style="margin-left:0;"><a name="uXPE-1690357664313"></a>5.文件存储空间管理</h4> 
         <p style="margin-left:0;"><a name="KoKF-1690549934981"></a></p> 
         <p><img alt="" height="390" src="https://i-blog.csdnimg.cn/blog_migrate/86054edbb9d9ec39a7be7146fec9634e.png" width="887"></p> 
         <h5 style="margin-left:0;"><a name="zU29-1690549956714"></a>1.文件卷</h5> 
         <p style="margin-left:0;"><a name="4iGN-1690550008526"></a>存储空间的划分:将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)。所谓的文件卷就相当于电脑上的C盘，D盘等。</p> 
         <p style="margin-left:0;"><a name="Jeba-1690550739709"></a></p> 
         <p><img alt="" height="539" src="https://i-blog.csdnimg.cn/blog_migrate/85a39eb96c7c64ce1a2c9d9811a5387c.png" width="641"></p> 
         <p style="margin-left:0;"><a name="ObHE-1690550014983"></a></p> 
         <p><img alt="" height="394" src="https://i-blog.csdnimg.cn/blog_migrate/a716039a1d92fddbcf835c9e081bffe6.png" width="961"></p> 
         <h5 style="margin-left:0;"><a name="KkTp-1690550037640"></a>2.空闲表法</h5> 
         <p style="margin-left:0;"><a name="VcV4-1690550038058"></a>为<strong>一个磁盘创建一个表，来存储空闲磁盘块的位置。</strong></p> 
         <p style="margin-left:0;"><a name="zZZY-1690550038060"></a>如何分配磁盘块 : 与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p> 
         <p style="margin-left:0;"><a name="HG9F-1690550038062"></a>如何回收磁盘块:与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况―—①回收区的前后都没有相邻空闲区;②回收区的前后都是空闲区;③回收区前面是空闲区;④回收区后面是空闲区。总之，回收时需要注意表项的合并问题。</p> 
         <p style="margin-left:0;"><a name="zhKS-1690550967292"></a></p> 
         <p><img alt="" height="404" src="https://i-blog.csdnimg.cn/blog_migrate/eaba43bfaa3b93946176dcab1b37bed2.png" width="916"></p> 
         <h5 style="margin-left:0;"><a name="ZK6N-1690550038064"></a>3.空闲链表法</h5> 
         <p style="margin-left:0;"><a name="dJb6-1690550038066"></a>空闲链表发分为空闲盘块链和空闲盘区链。</p> 
         <p style="margin-left:0;"><a name="cfpU-1690550187247"></a></p> 
         <p><img alt="" height="487" src="https://i-blog.csdnimg.cn/blog_migrate/5e00fc70b865455387b53ff2cb2e5bcd.png" width="854"></p> 
         <h5 style="margin-left:0;"><a name="kkd0-1690550038068"></a>4.空闲盘块链</h5> 
         <ol>
          <li><a name="f5Oh-1690550038070"></a>操作系统保存着链头、链尾指针。</li>
          <li><a name="yF3l-1690550038072"></a>如何分配:若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li>
          <li><a name="oZjw-1690550038074"></a>如何回收:回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li>
          <li><a name="D1FC-1690550038076"></a>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作。</li>
         </ol> 
         <p style="margin-left:0;"><a name="17Gn-1690550170221"></a></p> 
         <p><img alt="" height="414" src="https://i-blog.csdnimg.cn/blog_migrate/adff292b9e8565bd804b8153b37e04e1.png" width="396"></p> 
         <h5 style="margin-left:0;"><a name="F1iu-1690550038078"></a>5.空闲盘区链</h5> 
         <ol>
          <li><a name="ncST-1690550038080"></a>操作系统保存着链头、链尾指针。</li>
          <li><a name="medZ-1690550038082"></a>如何分配:若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</li>
          <li><a name="x6dv-1690550038084"></a>如何回收:若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li>
          <li><a name="YtDH-1690550038086"></a>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</li>
         </ol> 
         <p style="margin-left:0;"><a name="icN2-1690550140202"></a></p> 
         <p><img alt="" height="405" src="https://i-blog.csdnimg.cn/blog_migrate/6aad648e854d73cc5e358ed3cccb0175.png" width="499"></p> 
         <h5 style="margin-left:0;"><a name="ArXf-1690550038088"></a>6.位示图法</h5> 
         <p style="margin-left:0;"><a name="isNn-1690550038090"></a>位示图:每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此可以用(字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号)</p> 
         <p style="margin-left:0;"><a name="ysFe-1690550038092"></a><strong>(字号,位号)=(i j) 的二进制位对应的盘块号 b= ni + j</strong></p> 
         <p style="margin-left:0;"><a name="CGtf-1690550038094"></a>b号盘块对应的字号i = b/n，位号j = b%n。</p> 
         <p style="margin-left:0;"><a name="8dC1-1690550038096"></a>如何分配:若文件需要K个块，</p> 
         <p style="margin-left:0;"><a name="thpN-1690550038098"></a>①顺序扫描位示图，找到K个相邻或不相邻的“0”;</p> 
         <p style="margin-left:0;"><a name="Rj3W-1690550038100"></a>②根据字号、位号算出对应的盘块号，将相应盘块分配给文件;</p> 
         <p style="margin-left:0;"><a name="yW6N-1690550038102"></a>③将相应位设置为“1”。</p> 
         <p style="margin-left:0;"><a name="iiWH-1690550038104"></a>如何回收:</p> 
         <p style="margin-left:0;"><a name="igOj-1690550038106"></a>①根据回收的盘块号计算出对应的字号、位号;</p> 
         <p style="margin-left:0;"><a name="Q7Zd-1690550038108"></a>②将相应二进制位设为“0”。</p> 
         <p style="margin-left:0;"><a name="jEeI-1690550110271"></a></p> 
         <p><img alt="" height="510" src="https://i-blog.csdnimg.cn/blog_migrate/a63a8fc11088bfdf3d224297ffacb0e3.png" width="1049"></p> 
         <h5 style="margin-left:0;"><a name="BML2-1690550038110"></a>7.成组链接法</h5> 
         <p style="margin-left:0;"><a name="6NRc-1690550038112"></a>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。</p> 
         <p style="margin-left:0;"><a name="4WjK-1690550038114"></a>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。如图所示。</p> 
         <p style="margin-left:0;"><a name="C5eI-1690550101157"></a></p> 
         <p><img alt="" height="325" src="https://i-blog.csdnimg.cn/blog_migrate/4ac5fa56f2b34ee389de49c2563a392c.png" width="488"></p> 
         <ol>
          <li><a name="1nB1-1690550038116"></a>超级块中存储的内容</li>
         </ol> 
         <p style="margin-left:0;"><a name="eRkZ-1690550078167"></a></p> 
         <p><img alt="" height="557" src="https://i-blog.csdnimg.cn/blog_migrate/4444a5baffcca1c94a23414cd6b9bc5e.png" width="1134"></p> 
         <p style="margin-left:0;"><a name="M4JW-1690550038118"></a>如何分配?</p> 
         <p style="margin-left:0;"><a name="GqNX-1690550038120"></a>Eg :需要100个空闲块</p> 
         <p style="margin-left:0;"><a name="Z6PL-1690550038122"></a>①检查第一个分组的块数是否足够。100=100，是足够的。</p> 
         <p style="margin-left:0;"><a name="dUSu-1690550038125"></a>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中。</p> 
         <p style="margin-left:0;"><a name="NUXP-1690550038127"></a>Eg :需要1个空闲块</p> 
         <p style="margin-left:0;"><a name="lNwS-1690550038129"></a>①检查第一个分组的块数是否足够。1&lt;100，因此是足够的。</p> 
         <p style="margin-left:0;"><a name="BQSi-1690550038131"></a>②分配第一个分组中的1个空闲块，并修改相应数据</p> 
         <p style="margin-left:0;"><a name="27zM-1690550038133"></a>如何回收?</p> 
         <p style="margin-left:0;"><a name="Rw1o-1690550038135"></a>Eg :假设每个分组最多为100个空闲块，此时第一个分组已有99个块，还要再回收一块。</p> 
         <p style="margin-left:0;"><a name="dRpu-1690550038137"></a>Eg : 假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p> 
         <h4 style="margin-left:0;"><a name="7bCJ-1690357689250"></a>6.文件基本操作</h4> 
         <h5 style="margin-left:0;"><a name="xFxa-1690551782554"></a>1.创建文件</h5> 
         <p style="margin-left:0;"><a name="ArGF-1690551912494"></a>进行Create系统调用时，需要提供的几个主要参数:</p> 
         <p style="margin-left:0;"><a name="b6e0-1690551912496"></a>所需的外存空间大小（如:一个盘块，即1KB)</p> 
         <p style="margin-left:0;"><a name="AAun-1690551912498"></a>文件存放路径（“D:/Demo”)</p> 
         <p style="margin-left:0;"><a name="XcAV-1690551912500"></a>文件名（这个地方默认为“新建文本文档.txt”)</p> 
         <p style="margin-left:0;"><a name="tlEE-1690551912502"></a>操作系统在处理Create系统调用时，主要做了两件事:</p> 
         <p style="margin-left:0;"><a name="cVdd-1690551912504"></a>1.在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)</p> 
         <p style="margin-left:0;"><a name="h6EP-1690551912506"></a>2.根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</p> 
         <h5 style="margin-left:0;"><a name="3DRx-1690551912508"></a>2.删除文件</h5> 
         <p style="margin-left:0;"><a name="INND-1690551912511"></a>进行Delete系统调用时，需要提供的几个主要参数:</p> 
         <p style="margin-left:0;"><a name="zNDY-1690551912513"></a>1.文件存放路径（“D:/Demo”)</p> 
         <p style="margin-left:0;"><a name="Bias-1690551912515"></a>2.文件名（“test.txt”)</p> 
         <p style="margin-left:0;"><a name="G2po-1690551912517"></a>操作系统在处理Delete系统调用时，主要做了几件事:</p> 
         <p style="margin-left:0;"><a name="lzqU-1690551912519"></a>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p> 
         <p style="margin-left:0;"><a name="5WZD-1690551912521"></a>2．根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)</p> 
         <p style="margin-left:0;"><a name="xrO8-1690551912523"></a>3.从目录表中删除文件对应的目录项。</p> 
         <h5 style="margin-left:0;"><a name="KEpU-1690551912525"></a>3.打开文件</h5> 
         <p style="margin-left:0;"><a name="47td-1690551912527"></a>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数:</p> 
         <p style="margin-left:0;"><a name="fOKg-1690551912529"></a>1．文件存放路径（“D:/Demo”)</p> 
         <p style="margin-left:0;"><a name="YCbe-1690551912531"></a>2.文件名（ “test.txt”)</p> 
         <p style="margin-left:0;"><a name="pz1t-1690551912533"></a>3．要对文件的操作类型（如:r只读;rw读写等)</p> 
         <p style="margin-left:0;"><a name="q6rR-1690551912535"></a>操作系统在处理open系统调用时，主要做了几件事:</p> 
         <p style="margin-left:0;"><a name="jpRp-1690551912537"></a>1．根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p> 
         <p style="margin-left:0;"><a name="fgKC-1690551912539"></a>2．将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p> 
         <p style="margin-left:0;"><a name="xiES-1690551946424"></a></p> 
         <p><img alt="" height="617" src="https://i-blog.csdnimg.cn/blog_migrate/591dcca434cfb129e91ca0434a6bc5e9.png" width="794"></p> 
         <ol>
          <li><a name="uEHK-1690551912541"></a>需要注意的是，有两张打开文件表，一个是进程自带的，另一个是系统的（只有一张）。</li>
         </ol> 
         <p style="margin-left:0;"><a name="Sxwq-1690551958267"></a></p> 
         <p><img alt="" height="702" src="https://i-blog.csdnimg.cn/blog_migrate/7ac41281f267dbc5e1c2f370993a489e.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="YFZM-1690551912543"></a>4.关闭文件</h5> 
         <p style="margin-left:0;"><a name="2zw4-1690551912545"></a>进程使用完文件后，要“关闭文件”。</p> 
         <p style="margin-left:0;"><a name="XdhH-1690551912547"></a>操作系统在处理Close系统调用时，主要做了几件事:</p> 
         <p style="margin-left:0;"><a name="z09s-1690551912549"></a>1.将进程的打开文件表相应表项删除</p> 
         <p style="margin-left:0;"><a name="I3FR-1690551912551"></a>2.回收分配给该文件的内存空间等资源</p> 
         <p style="margin-left:0;"><a name="wKHf-1690551912553"></a>3.系统打开文件表的打开计数器count 减1，若count =0，则删除对应表项。</p> 
         <h5 style="margin-left:0;"><a name="WA8e-1690551912555"></a>5.读文件</h5> 
         <p style="margin-left:0;"><a name="U9iV-1690551912557"></a>进程使用read系统调用完成写操作。</p> 
         <p style="margin-left:0;"><a name="1FxA-1690551912559"></a>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，</p> 
         <p style="margin-left:0;"><a name="vynQ-1690551912561"></a>还需要指明要读入多少数据（如:读入1KB）、</p> 
         <p style="margin-left:0;"><a name="6VHc-1690551912563"></a>指明读入的数据要放在内存中的什么位置。</p> 
         <p style="margin-left:0;"><a name="GS2u-1690551912565"></a>操作系统在处理read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p> 
         <h5 style="margin-left:0;"><a name="F2y8-1690551912567"></a>6.写文件</h5> 
         <p style="margin-left:0;"><a name="G0Io-1690551912569"></a>进程使用write系统调用完成写操作，</p> 
         <p style="margin-left:0;"><a name="KYcv-1690551912571"></a>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），</p> 
         <p style="margin-left:0;"><a name="pjcn-1690551912573"></a>还需要指明要写出多少数据（如:写出1KB)、</p> 
         <p style="margin-left:0;"><a name="sYEA-1690551912575"></a>写回外存的数据放在内存中的什么位置</p> 
         <p style="margin-left:0;"><a name="aUm6-1690551912577"></a>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p> 
         <h4 style="margin-left:0;"><a name="q84H-1690357699187"></a>7.文件共享</h4> 
         <h5 style="margin-left:0;"><a name="i2eW-1690553131124"></a>1.基于索引节点的共享方式（硬链接）</h5> 
         <p style="margin-left:0;"><a name="sTlR-1690553504887"></a>硬链接也就是是同一个文件</p> 
         <p style="margin-left:0;"><a name="qMg8-1690553131407"></a>知识回顾:索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p> 
         <p style="margin-left:0;"><a name="eYhK-1690553141528"></a></p> 
         <p><img alt="" height="299" src="https://i-blog.csdnimg.cn/blog_migrate/a5169807b2df2b6dced98ba3448ea13a.png" width="1156"></p> 
         <p style="margin-left:0;"><a name="CZjI-1690553131409"></a>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p> 
         <p style="margin-left:0;"><a name="SZ6g-1690553131411"></a>若count =2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。</p> 
         <p style="margin-left:0;"><a name="XWUa-1690553131413"></a>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。当count =0时系统负责删除文件。</p> 
         <h5 style="margin-left:0;"><a name="zJqV-1690553131415"></a>2.基于符号链的共享方式（软链接）</h5> 
         <p style="margin-left:0;"><a name="SYCG-1690553515124"></a>软链接只是执行文件的地址</p> 
         <p style="margin-left:0;"><a name="eBWs-1690553131417"></a>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。类似于快捷方式。</p> 
         <p style="margin-left:0;"><a name="xbfB-1690553147216"></a></p> 
         <p><img alt="" height="475" src="https://i-blog.csdnimg.cn/blog_migrate/f55b5667db8cd6d8c6917888c132ef50.png" width="1174"></p> 
         <h4 style="margin-left:0;"><a name="IgW5-1690357707171"></a>8.文件保护</h4> 
         <h5 style="margin-left:0;"><a name="HL9a-1690553192839"></a>1.口令保护</h5> 
         <p style="margin-left:0;"><a name="edEX-1690555782072"></a>为文件设置一个“口令”(如: abc112233），<strong>用户请求访问该文件时必须提供“口令”</strong>。</p> 
         <p style="margin-left:0;"><a name="vlhM-1690555782074"></a>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。</p> 
         <p style="margin-left:0;"><a name="VJoY-1690555782076"></a>优点:保存口令的空间开销不多，验证口令的时间开销也很小。</p> 
         <p style="margin-left:0;"><a name="RIz0-1690555782078"></a>缺点:正确的“口令”存放在系统内部，不够安全。</p> 
         <h5 style="margin-left:0;"><a name="dXAO-1690555782080"></a>2.加密保护</h5> 
         <p style="margin-left:0;"><a name="6dGd-1690555782082"></a>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p> 
         <p style="margin-left:0;"><a name="TcBi-1690555782084"></a>Eg:一个最简单的加密算法――<strong>异或加密。</strong></p> 
         <p style="margin-left:0;"><a name="hQRh-1690555782086"></a>假设用于加密/解密的“密码”为“01001”。</p> 
         <p style="margin-left:0;"><a name="yZEI-1690555826459"></a></p> 
         <p><img alt="" height="275" src="https://i-blog.csdnimg.cn/blog_migrate/d0d4c70d3c5c61ce975ed73d937eb5c8.png" width="1019"></p> 
         <ol>
          <li><a name="Anxr-1690555782088"></a>优点:保密性强，不需要在系统中存储“密码”。</li>
          <li><a name="TDZ0-1690555782090"></a>缺点:编码/译码，或者说加密/解密要花费一定时间。</li>
         </ol> 
         <h5 style="margin-left:0;"><a name="2RHY-1690555782092"></a>3.访问控制</h5> 
         <p style="margin-left:0;"><a name="2G8q-1690555782095"></a>在每个文件的FCB（或索引结点）中增加一个访问控制列表(Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。如图所示：</p> 
         <p style="margin-left:0;"><a name="W7VH-1690555833921"></a></p> 
         <p><img alt="" height="404" src="https://i-blog.csdnimg.cn/blog_migrate/ba1d01e36f87e87f3d73a4ebd20f597b.png" width="1083"></p> 
         <p style="margin-left:0;"><a name="POdt-1690555863492"></a>在windows中也就是：</p> 
         <p style="margin-left:0;"><a name="ctA1-1690555866370"></a></p> 
         <p><img alt="" height="789" src="https://i-blog.csdnimg.cn/blog_migrate/ae1e28f2b7b836324a8dd9bb7334dd75.png" width="638"></p> 
         <p style="margin-left:0;"><a name="EqD5-1690555782097"></a>精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作。如:分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p> 
         <p style="margin-left:0;"><a name="xo7R-1690555893945"></a></p> 
         <p><img alt="" height="285" src="https://i-blog.csdnimg.cn/blog_migrate/757a9d9b264f3bc55a5ca1e4293bcb8d.png" width="966"></p> 
         <h5 style="margin-left:0;"><a name="zZZ8-1690555782099"></a>4.总结</h5> 
         <p style="margin-left:0;"><a name="spcN-1690555902303"></a></p> 
         <p><img alt="" height="465" src="https://i-blog.csdnimg.cn/blog_migrate/8b4ab8c6e036ead75e578a8ea4a0e737.png" width="1106"></p> 
         <h4 style="margin-left:0;"><a name="5bCW-1690357721922"></a>9.文件层次机构</h4> 
         <p style="margin-left:0;"><a name="eNka-1690555937214"></a></p> 
         <p><img alt="" height="709" src="https://i-blog.csdnimg.cn/blog_migrate/c8b3483d55ee0409567d79934c3a76d6.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="Cph1-1690555923768"></a>用一个例子来辅助记忆文件系统的层次结构:</p> 
         <p style="margin-left:0;"><a name="OF39-1690555931355"></a>假设某用户请求删除文件“D:/工作目录/学生信息.xlsx”的最后100条记录。</p> 
         <ol>
          <li><a name="TxFq-1690555931357"></a> 用户需要通过操作系统提供的接口发出上述请求一用户接口。</li>
          <li><a name="Oi1I-1690555931359"></a> 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项――文件目录系统</li>
          <li><a name="ivx8-1690555931361"></a> 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限―一存取控制模块（存取控制验证层)</li>
          <li><a name="I7Eb-1690555931363"></a> 验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――逻辑文件系统与文件信息缓冲区</li>
          <li><a name="udkh-1690555931365"></a> 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――物理文件系统</li>
          <li><a name="oSHI-1690555931367"></a> 要删除这条记录，必定要对磁盘设备发出请求――设备管理程序模块</li>
          <li><a name="IXEG-1690555931369"></a> 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――辅助分配模块。</li>
         </ol> 
         <h4 style="margin-left:0;"><a name="wDsA-1690357734696"></a>10.磁盘结构</h4> 
         <ol>
          <li><a name="znTw-1690555946073"></a>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</li>
          <li><a name="fzQ4-1690555950652"></a>磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</li>
          <li><a name="PAZr-1690555950654"></a>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。<strong>各个扇区存放的数据量相同</strong>（如1KB)。</li>
         </ol> 
         <p style="margin-left:0;"><a name="IWsU-1690555955250"></a></p> 
         <p><img alt="" height="626" src="https://i-blog.csdnimg.cn/blog_migrate/f5166088e7d2aa64e09bb9c497dee09a.png" width="1160"></p> 
         <ol>
          <li><a name="Jpon-1690555964755"></a>所有盘面中相对位置相同的磁道组成柱面。</li>
         </ol> 
         <p style="margin-left:0;"><a name="v2Qm-1690555969736"></a></p> 
         <p><img alt="" height="645" src="https://i-blog.csdnimg.cn/blog_migrate/0082eb678d4c3ce8838ed4818611d127.png" width="767"></p> 
         <ol>
          <li><a name="RUZz-1690555986183"></a><strong>可用(柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。</strong></li>
          <li><a name="1oM2-1690555986691"></a>可根据该地址读取一个“块”</li>
         </ol> 
         <p style="margin-left:0;"><a name="5F0h-1690555986693"></a>①根据“柱面号”移动磁臂，让磁头指向指定柱面;</p> 
         <p style="margin-left:0;"><a name="9fBZ-1690555986695"></a>②激活指定盘面对应的磁头;</p> 
         <p style="margin-left:0;"><a name="xrmS-1690555986697"></a>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这<img alt="" height="212" src="https://i-blog.csdnimg.cn/blog_migrate/dd7ba646c60e395d0f237211a4ca0235.png" width="990"></p> 
         <h4 style="margin-left:0;"><a name="4Kb2-1690357741119"></a>11.磁盘调度算法</h4> 
         <h5 style="margin-left:0;"><a name="pLZJ-1690556104003"></a>1.一次磁盘读/写操作需要的时间</h5> 
         <p style="margin-left:0;"><a name="jF7W-1690556270453"></a></p> 
         <p><img alt="" height="493" src="https://i-blog.csdnimg.cn/blog_migrate/702b112960931190fd2ad3464404d65e.png" width="536"></p> 
         <ol>
          <li><a name="O2f6-1690556248890"></a><strong>寻找时间</strong>(寻道时间)Ts:在读/写数据前，将磁头移动到指定磁道所花的时间。</li>
         </ol> 
         <p style="margin-left:0;"><a name="jhlR-1690556248892"></a>①启动磁头臂是需要时间的。假设耗时为s;</p> 
         <p style="margin-left:0;"><a name="Fqok-1690556248894"></a>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则:</p> 
         <p style="margin-left:0;"><a name="0pKN-1690556248896"></a>寻道时间Ts = s + m<strong>n</strong></p> 
         <ol>
          <li><a name="BccY-1690556294155"></a><strong>延迟时间T:通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位:转/秒，或转/分），则平均所需的延迟时间T=(1/2)</strong>(1/r)= 1/2r。</li>
         </ol> 
         <p style="margin-left:0;"><a name="jc3i-1690556248898"></a>1/r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1/2</p> 
         <ol>
          <li><a name="3vqg-1690556248900"></a>传输时间Tt:从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。则:</li>
          <li><a name="VrHv-1690556248902"></a>传输时间Tt = (1/r)*(b/N) = b/(rN)</li>
         </ol> 
         <p style="margin-left:0;"><a name="4oFu-1690556248904"></a>每个磁道要可存N字节的数据，因此b字节的数据需要b/N个磁道才能存储。而读/写一个磁道所需的时间刚好又是转一圈所需要的时间1/r。</p> 
         <ol>
          <li><a name="5ZhR-1690556248906"></a>总的平均存取时间 T=Ts+ 1/2r + b/(rN)</li>
         </ol> 
         <p style="margin-left:0;"><a name="hLnF-1690556248908"></a>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。但是操作系统的磁盘调度算法会直接影响寻道时间。</p> 
         <h5 style="margin-left:0;"><a name="W1TR-1690556248910"></a>2.先来先服务算法</h5> 
         <ol>
          <li><a name="68V2-1690556248912"></a>根据进程请求访问磁盘的先后顺序进行调度。</li>
         </ol> 
         <p style="margin-left:0;"><a name="u2yA-1690556331485"></a></p> 
         <p><img alt="" height="440" src="https://i-blog.csdnimg.cn/blog_migrate/4f1ace6e5298ed37e20dc24d59ce3d57.png" width="1022"></p> 
         <h5 style="margin-left:0;"><a name="AZXv-1690556248914"></a>3. 最短寻找时间优先（SSTF）</h5> 
         <p style="margin-left:0;"><a name="f9fZ-1690556248916"></a>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)</p> 
         <p style="margin-left:0;"><a name="cx4g-1690556358812"></a></p> 
         <p><img alt="" height="405" src="https://i-blog.csdnimg.cn/blog_migrate/3f473ea5a5d39736ccf460f343ebc81a.png" width="990"></p> 
         <h5 style="margin-left:0;"><a name="krXg-1690556248918"></a>4.扫描算法（SCAN）</h5> 
         <p style="margin-left:0;"><a name="IxJ5-1690556248920"></a>SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有<strong>磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</strong>。这就是扫描算法（SCAN)的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p> 
         <p style="margin-left:0;"><a name="iz1D-1690556466513"></a></p> 
         <p><img alt="" height="409" src="https://i-blog.csdnimg.cn/blog_migrate/2d378964e59f40548b0831bc6d479753.png" width="1064"></p> 
         <h5 style="margin-left:0;"><a name="6KOy-1690556248922"></a>5.LOOK调度算法</h5> 
         <p style="margin-left:0;"><a name="DZEK-1690556248924"></a>扫描算法（SCAN)中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法就是为了解决这个问题，<strong>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。</strong>(边移动边观察，因此叫LOOK)。</p> 
         <p style="margin-left:0;"><a name="nRuR-1690556477513"></a></p> 
         <p><img alt="" height="386" src="https://i-blog.csdnimg.cn/blog_migrate/eb7fb6533f1d04a64c449210a8f8f131.png" width="1013"></p> 
         <h5 style="margin-left:0;"><a name="cglo-1690556248926"></a>6.循环扫描算法（C—SCAN）</h5> 
         <p style="margin-left:0;"><a name="wGP0-1690556248928"></a>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p> 
         <p style="margin-left:0;"><a name="S5a7-1690556539553"></a></p> 
         <p><img alt="" height="389" src="https://i-blog.csdnimg.cn/blog_migrate/f346a66dcde8e038ee27f04b5496a7b4.png" width="995"></p> 
         <h5 style="margin-left:0;"><a name="nmoA-1690556248930"></a>7.C-LOOK调度算法</h5> 
         <p style="margin-left:0;"><a name="aiDx-1690556248932"></a>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p> 
         <p style="margin-left:0;"><a name="E7K7-1690556565574"></a></p> 
         <p><img alt="" height="363" src="https://i-blog.csdnimg.cn/blog_migrate/aa6dcf59afe5875c553adfd69bc9f363.png" width="1056"></p> 
         <h4 style="margin-left:0;"><a name="2z53-1690357754358"></a>12.减少延迟时间的方法</h4> 
         <p style="margin-left:0;"><a name="dyDz-1690556660620"></a></p> 
         <p><img alt="" height="162" src="https://i-blog.csdnimg.cn/blog_migrate/c195b26257b0df083c2719f258488061.png" width="1175"></p> 
         <p style="margin-left:0;"><a name="YIkF-1690357767521"></a>假设要连续读取橙色区域的2、3、4扇区:</p> 
         <p style="margin-left:0;"><a name="wwn5-1690556669882"></a>磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停地旋转</p> 
         <p style="margin-left:0;"><a name="EQZQ-1690556669884"></a>因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区</p> 
         <p style="margin-left:0;"><a name="hxn1-1690556669886"></a>必须等盘片继续旋转，3号扇区再次划过磁头，才能完成扇区读入。</p> 
         <p style="margin-left:0;"><a name="GqGF-1690556669888"></a>结论:磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。</p> 
         <p style="margin-left:0;"><a name="kiO0-1690556685636"></a></p> 
         <p><img alt="" height="376" src="https://i-blog.csdnimg.cn/blog_migrate/61f05505b6622bda501163e69f63b764.png" width="396"></p> 
         <h5 style="margin-left:0;"><a name="JncK-1690556669890"></a>1.交替编号</h5> 
         <p style="margin-left:0;"><a name="35hN-1690556669892"></a>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。如图所示。</p> 
         <p style="margin-left:0;"><a name="gpH7-1690556714707"></a></p> 
         <p><img alt="" height="397" src="https://i-blog.csdnimg.cn/blog_migrate/1974ca699cbbdd27ced07ac195d531a4.png" width="381"></p> 
         <h5 style="margin-left:0;"><a name="7Uew-1690556669894"></a>2.磁盘地址结构的设计</h5> 
         <p style="margin-left:0;"><a name="2gsm-1690556669897"></a>思考:为什么磁盘的物理地址是（柱面号，盘面号，扇区号)，而不是(盘面号，柱面号，扇区号)？</p> 
         <p style="margin-left:0;"><a name="COWI-1690556669899"></a>答:读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</p> 
         <h5 style="margin-left:0;"><a name="LOVP-1690556669903"></a>3.错位命名</h5> 
         <p style="margin-left:0;"><a name="Fz7Z-1690556754593"></a></p> 
         <p><img alt="" height="663" src="https://i-blog.csdnimg.cn/blog_migrate/b2965d48b708372bdb61247dcde0fd3e.png" width="1106"></p> 
         <h4 style="margin-left:0;"><a name="XK1M-1690556662510"></a>13.磁盘的管理</h4> 
         <h5 style="margin-left:0;"><a name="DJqX-1690556760814"></a>&nbsp;1.磁盘初始化</h5> 
         <p style="margin-left:0;"><a name="l7bw-1690556770980"></a>磁盘初始化:</p> 
         <p style="margin-left:0;"><a name="LihD-1690556770982"></a>Step 1:进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)</p> 
         <p style="margin-left:0;"><a name="IgYj-1690556770984"></a>Step 2:将磁盘分区，每个分区由若干柱面（磁道）组成（即分为我们熟悉的C盘、D盘、E盘)</p> 
         <p style="margin-left:0;"><a name="dKrH-1690556770986"></a>step 3:进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)</p> 
         <p style="margin-left:0;"><a name="d16P-1690556784312"></a></p> 
         <p><img alt="" height="375" src="https://i-blog.csdnimg.cn/blog_migrate/c9de8b69ecfe8c960d04c14e0fc5b5a8.png" width="368"></p> 
         <h5 style="margin-left:0;"><a name="ua59-1690556770988"></a>2.引导块</h5> 
         <p style="margin-left:0;"><a name="lzat-1690556770990"></a>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p> 
         <p style="margin-left:0;"><a name="bqaw-1690556770992"></a>初始化程序可以放在ROM(只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改 。</p> 
         <p style="margin-left:0;"><a name="gDWh-1690556770994"></a>初始化程序程序（自举程序）放在ROM中存在什么问题?万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改。如何解决呢?</p> 
         <p style="margin-left:0;"><a name="MVJT-1690556770996"></a>ROM中只存放很小的“自举装入程序”。开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</p> 
         <p style="margin-left:0;"><a name="0vjB-1690556770998"></a>完整的自举程序放在磁盘的启动块(即引导块/启动分区)上，启动块位于磁盘的固定位置。</p> 
         <p style="margin-left:0;"><a name="Ap6R-1690556771000"></a>拥有启动分区的磁盘称为启动磁盘或系统磁盘（c:盘)</p> 
         <h5 style="margin-left:0;"><a name="Kmnu-1690556771002"></a>3.坏块的管理</h5> 
         <ol>
          <li><a name="SywP-1690556771004"></a>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</li>
          <li><a name="e8ac-1690556771006"></a>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时)对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如:在FAT表上标明。（在这种方式中，坏块对操作系统不透明)</li>
          <li><a name="LRB0-1690556771008"></a>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。</li>
         </ol> 
         <p style="margin-left:0;"><a name="asyi-1690556771010"></a>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。</p> 
         <p style="margin-left:0;"><a name="ko2s-1690556771012"></a>会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</p> 
         <p style="margin-left:0;"><a name="74KF-1690556871864"></a></p> 
         <h2 style="margin-left:0;"><a name="WUWp-1690556873315"></a>五、I/O管理</h2> 
         <h4 style="margin-left:0;"><a name="OFkD-1690556880915"></a>1.I/O设备的概念</h4> 
         <ol>
          <li><a name="JUm0-1690640200659"></a>“I/O” 就是“输入/输出”(Input/Output)</li>
          <li><a name="qLq3-1690640200882"></a>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</li>
         </ol> 
         <p style="margin-left:0;"><a name="QxcG-1690640203024"></a>i设备：鼠标、键盘、<span style="background-color:#ffffff;"><span style="color:#333333;">写字板、麦克风</span></span></p> 
         <p style="margin-left:0;"><a name="subR-1690640407673"></a>o设备：显示器、耳机</p> 
         <p style="margin-left:0;"><a name="rqoF-1690640771384"></a>输入输出设备：云盘</p> 
         <h4 style="margin-left:0;"><a name="sM2F-1690556904694"></a>2.I/O控制器</h4> 
         <h5 style="margin-left:0;"><a name="wyUM-1690640789787"></a>1.含义</h5> 
         <p style="margin-left:0;"><a name="Qac7-1690640799759"></a>CPU无法直接控制l/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</p> 
         <p style="margin-left:0;"><a name="1HYJ-1690640799761"></a>这个电子部件就是I/O控制器，又称设备控制器。CPU可控制I/o控制器，又由I/O控制器来控制设备的机械部件。</p> 
         <h5 style="margin-left:0;"><a name="wFdq-1690640799763"></a>2.功能</h5> 
         <p style="margin-left:0;"><a name="aaJL-1690640806185"></a></p> 
         <p><img alt="" height="385" src="https://i-blog.csdnimg.cn/blog_migrate/5651fa5935e6b815cf951c7ecbb85f72.png" width="989"></p> 
         <h5 style="margin-left:0;"><a name="kC3W-1690640799765"></a>3.组成</h5> 
         <p style="margin-left:0;"><a name="C4Lt-1690640815192"></a></p> 
         <p><img alt="" height="602" src="https://i-blog.csdnimg.cn/blog_migrate/9cbe34fc384060cd7a5f415118d650a7.png" width="1017"></p> 
         <h4 style="margin-left:0;"><a name="48Nl-1690556911094"></a>3.I/O控制方式</h4> 
         <h5 style="margin-left:0;"><a name="MPPd-1690640863143"></a>1.程序直接控制方式</h5> 
         <ol>
          <li><a name="MDVh-1690640882320"></a>完成一次读/写操作的流程图(以读操作为例）</li>
         </ol> 
         <p style="margin-left:0;"><a name="AwZ7-1690640896294"></a></p> 
         <p><img alt="" height="783" src="https://i-blog.csdnimg.cn/blog_migrate/ded6245daf507b28fc70a4fb4e7547d1.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="VcST-1690640882322"></a>流程图</p> 
         <p style="margin-left:0;"><a name="JkPs-1690640933323"></a></p> 
         <p><img alt="" height="763" src="https://i-blog.csdnimg.cn/blog_migrate/cfc32089e9c3fc3ddd099664f3405349.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="C2cx-1690640882324"></a>2.中断驱动方式</h5> 
         <ol>
          <li><a name="lXq8-1690640882326"></a>由于程序直接控制方式CPU利用率低，忙等，所以提出了中断驱动方式。</li>
         </ol> 
         <p style="margin-left:0;"><a name="oEA7-1690641534332"></a></p> 
         <p><img alt="" height="666" src="https://i-blog.csdnimg.cn/blog_migrate/4e765def84ba4b91c97783b0dc079759.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="uF8E-1690641550339"></a></p> 
         <p><img alt="" height="676" src="https://i-blog.csdnimg.cn/blog_migrate/d29e0a1e98757b49ec4751e70606d27c.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="dMU0-1690641548886"></a>3.DMA方式</h5> 
         <p style="margin-left:0;"><a name="3kLP-1690640882330"></a>虽然中断驱动方式解决了程序直接控制方式的问题，但是每一次只能读/写一个字，导致CPU频繁切换，耗费了很多时间。于是人们又发明了DMA方式。</p> 
         <p style="margin-left:0;"><a name="q5YH-1690641675369"></a></p> 
         <p><img alt="" height="581" src="https://i-blog.csdnimg.cn/blog_migrate/b252eb9c2c5235f445a70bb945c4bf95.png" width="1148"></p> 
         <ol>
          <li><a name="XYCS-1690640882334"></a>DMA控制器</li>
         </ol> 
         <p style="margin-left:0;"><a name="6HtJ-1690641698392"></a></p> 
         <p><img alt="" height="775" src="https://i-blog.csdnimg.cn/blog_migrate/643fcd5fdb2fa365c61b72f7ab7506f0.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="q0MV-1690641704407"></a></p> 
         <p><img alt="" height="667" src="https://i-blog.csdnimg.cn/blog_migrate/a3f2fdb38ee45acc60c91d465eea88e7.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="SIYF-1690641679506"></a>4.通道控制方式</h5> 
         <p style="margin-left:0;"><a name="bhBf-1690640882336"></a>通道控制方式是为了解决DMA方式连续存储的问题</p> 
         <p style="margin-left:0;"><a name="RxRG-1690641985423"></a></p> 
         <p><img alt="" height="794" src="https://i-blog.csdnimg.cn/blog_migrate/bd4a332912f39f15eb9a5fb0ef4b0daa.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="xVIt-1690642001166"></a></p> 
         <p></p> 
         <h5 style="margin-left:0;"><a name="tz0Y-1690641992493"></a>5.四种方式总结</h5> 
         <p style="margin-left:0;"><a name="0CEr-1690642010465"></a></p> 
         <p><img alt="" height="735" src="https://i-blog.csdnimg.cn/blog_migrate/ffa0fe9c2e7ad19461e9f7bd3abdb46a.png" width="1200"></p> 
         <h4 style="margin-left:0;"><a name="srNi-1690556922981"></a>4.I/O软件层次结构</h4> 
         <h5 style="margin-left:0;"><a name="Be0B-1690642057954"></a>1.知识总览</h5> 
         <p style="margin-left:0;"><a name="QqrU-1690642052476"></a></p> 
         <p><img alt="" height="507" src="https://i-blog.csdnimg.cn/blog_migrate/0865417e510bcc3e7ca31f21b9a74ec2.png" width="1060"></p> 
         <h5 style="margin-left:0;"><a name="haRu-1690556942250"></a>2.用户层软件</h5> 
         <ol>
          <li><a name="ookD-1690642075555"></a>用户层软件实现了与<strong>用户交互的接口，用户可直接使用该层提供的、与I/o操作相关的库函数对设备进行操作</strong>。</li>
          <li><a name="fgJi-1690642075557"></a>用户层软件将用户请求翻译成格式化的I/o请求，并通过“系统调用”请求操作系统内核的服务。</li>
         </ol> 
         <p style="margin-left:0;"><a name="0JLI-1690642240692"></a></p> 
         <p><img alt="" height="485" src="https://i-blog.csdnimg.cn/blog_migrate/6fa2efcd756ae869084592328cb7506b.png" width="1149"></p> 
         <h5 style="margin-left:0;"><a name="F5yG-1690642108168"></a>3.设备独立性软件</h5> 
         <p style="margin-left:0;"><a name="16Dz-1690642108170"></a>设备独立性软件，又称<strong>设备无关性软件</strong>。与设备的硬件特性无关的功能几乎都在这一层实现。</p> 
         <p style="margin-left:0;"><a name="5Ysw-1690642108172"></a>主要功能：</p> 
         <ol>
          <li><a name="ZipC-1690642108174"></a> 向上层提供统一的调用接口（如read/write系统调用)</li>
          <li><a name="41So-1690642108176"></a> 设备的保护。（原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。）</li>
          <li><a name="JKx9-1690642108178"></a> 差错处理（设备独立性软件需要对一些设备的错误进行处理）</li>
          <li><a name="VXN3-1690642108180"></a> 设备的分配与回收</li>
          <li><a name="IC0L-1690642108182"></a> 数据缓冲区管理（可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异）</li>
          <li><a name="HUEM-1690642108184"></a> 建立逻辑设备名到物理设备名的映射关系;根据设备类型选择调用相应的驱动程序</li>
          <li><a name="qwvH-1690642108186"></a> 用户或用户层软件发出I/o操作相关系统调用的系统调用时，需要指明此次要操作的I/o设备的逻辑设备名（eg:去学校打印店打印时，需要选择打印机1/打印机2/打印机3，其实这些都是逻辑设备名)</li>
         </ol> 
         <p style="margin-left:0;"><a name="mPpF-1690642108188"></a>设备独立性软件需要通过“逻辑设备表（LUT，Logical UnitTable）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。如图所示：</p> 
         <p style="margin-left:0;"><a name="iLzo-1690642372718"></a></p> 
         <p><img alt="" height="240" src="https://i-blog.csdnimg.cn/blog_migrate/7e8c9ba5f762906f55502d8887a7dde1.png" width="684"></p> 
         <p style="margin-left:0;"><a name="xavf-1690642108190"></a>操作系统系统可以采用两种方式管理逻辑设备表(LUT) :</p> 
         <p style="margin-left:0;"><a name="14kX-1690642108192"></a>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</p> 
         <p style="margin-left:0;"><a name="Z9yw-1690642108194"></a>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</p> 
         <h5 style="margin-left:0;"><a name="pJ8Y-1690642108196"></a>4.驱动设备</h5> 
         <p style="margin-left:0;"><a name="CdpC-1690642108198"></a>思考:为何不同的设备需要不同的设备驱动程序?</p> 
         <p style="margin-left:0;"><a name="6MQN-1690642108200"></a>不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p> 
         <p style="margin-left:0;"><a name="Nxgi-1690643104820"></a></p> 
         <p><img alt="" height="552" src="https://i-blog.csdnimg.cn/blog_migrate/d1e8ee0b8de43dd788f6797f639c4a8c.png" width="1112"></p> 
         <h5 style="margin-left:0;"><a name="pjyC-1690642108202"></a>5.中断处理程序</h5> 
         <p style="margin-left:0;"><a name="smzl-1690642108204"></a>当I/o任务完成时，I/o控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下:</p> 
         <p style="margin-left:0;"><a name="BEFT-1690643307365"></a></p> 
         <p><img alt="" height="381" src="https://i-blog.csdnimg.cn/blog_migrate/0a70ce3ba404a629c0f018d3250bc8df.png" width="1107"></p> 
         <h5 style="margin-left:0;"><a name="XUZZ-1690642108206"></a>6.总结</h5> 
         <h5 style="margin-left:0;"><a name="HYvU-1690642075559"></a></h5> 
         <p style="margin-left:0;"><a name="XlPn-1690643348860"></a></p> 
         <p><img alt="" height="438" src="https://i-blog.csdnimg.cn/blog_migrate/e5cd8237a1327dbe249a6af3680b8cc0.png" width="1155"></p> 
         <h4 style="margin-left:0;"><a name="ux5h-1690642064140"></a>5.I/O核心子系统</h4> 
         <h5 style="margin-left:0;"><a name="W54L-1690643360533"></a>1.知识总览</h5> 
         <p style="margin-left:0;"><a name="yUJw-1690643402493"></a></p> 
         <p style="margin-left:0;"><a name="zOdM-1690643412903"></a></p> 
         <p><img alt="" height="512" src="https://i-blog.csdnimg.cn/blog_migrate/8a0c03e4f4c7df14df449c814e1a910c.png" width="1182"></p> 
         <ul>
          <li><a name="dhz2-1690643402495"></a>这些功能在哪些层次上实现呢？</li>
         </ul> 
         <p style="margin-left:0;"><a name="HGxW-1690643486918"></a></p> 
         <p><img alt="" height="322" src="https://i-blog.csdnimg.cn/blog_migrate/f841743e387a483ac8cd8f32f03850e0.png" width="830"></p> 
         <h5 style="margin-left:0;"><a name="HVYB-1690643485582"></a>2.I/O调度</h5> 
         <p style="margin-left:0;"><a name="g0ui-1690643402497"></a><strong>I/O调度:用某种算法确定一个好的顺序来处理各个I/o请求。</strong></p> 
         <p style="margin-left:0;"><a name="IIwc-1690643402499"></a>如:磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。</p> 
         <p style="margin-left:0;"><a name="7g4w-1690643402501"></a>当多个磁盘I/o请求到来时，用某种调度算法确定满足I/o请求的顺序。</p> 
         <p style="margin-left:0;"><a name="POqv-1690643402503"></a>同理，打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定IV/o调度顺序。</p> 
         <h5 style="margin-left:0;"><a name="XYPK-1690643402505"></a>3.设备保护</h5> 
         <p style="margin-left:0;"><a name="RY8w-1690643402507"></a>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如:只读、读和写等）。</p> 
         <p style="margin-left:0;"><a name="ulgA-1690643402509"></a>在UNIx系统中，<strong>设备被看做是一种特殊的文件</strong>，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)</p> 
         <h4 style="margin-left:0;"><a name="yTjW-1690556953248"></a>6.假脱机技术</h4> 
         <h5 style="margin-left:0;"><a name="tENG-1690643519594"></a>1.脱机技术</h5> 
         <ol>
          <li><a name="qKdO-1690643526543"></a>手工操作阶段:主机直接从l/o设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。因此在批处理阶段引入了脱机输入/输出技术（用磁带完成).</li>
         </ol> 
         <p style="margin-left:0;"><a name="BlDv-1690643526545"></a>Tips:为什么称为“脱机”？一脱离主机的控制进行的输入/输出操作。</p> 
         <p style="margin-left:0;"><a name="P9Kz-1690643534007"></a></p> 
         <p><img alt="" height="465" src="https://i-blog.csdnimg.cn/blog_migrate/262760aefc941301b628f55b03596188.png" width="1012"></p> 
         <h5 style="margin-left:0;"><a name="ePGs-1690643526548"></a>2.假脱机技术</h5> 
         <p style="margin-left:0;"><a name="bsty-1690643526550"></a>“假脱机技术”，又称“SPOOLing 技术”，用软件的方式模拟脱机技术。SPOQLing系统的组成如下:</p> 
         <ol>
          <li><a name="zxO0-1690643526552"></a>“输入井”模拟脱机输入时的磁带，用于收容I/o设备输入的数据</li>
          <li><a name="48v3-1690643526554"></a>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</li>
          <li><a name="A85T-1690643526556"></a>“输入进程”模拟脱机输入时的外围控制机</li>
          <li><a name="Weet-1690643526558"></a>“输出进程”模拟脱机输出时的外围控制机</li>
         </ol> 
         <p style="margin-left:0;"><a name="juq1-1690643559027"></a></p> 
         <p><img alt="" height="426" src="https://i-blog.csdnimg.cn/blog_migrate/6013ed62f42b3d2ff333d0148290461d.png" width="995"></p> 
         <p style="margin-left:0;"><a name="64k4-1690643526560"></a>要实现SPOOLing 技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”。</p> 
         <h4 style="margin-left:0;"><a name="Vb0d-1690556961334"></a>7.设备的分配和回收</h4> 
         <h5 style="margin-left:0;"><a name="0EAB-1690643575069"></a>1.知识总览</h5> 
         <p style="margin-left:0;"><a name="J6y1-1690643625871"></a></p> 
         <p><img alt="" height="473" src="https://i-blog.csdnimg.cn/blog_migrate/2ce58323ca8257a7a3011f258ce2319a.png" width="1068"></p> 
         <h5 style="margin-left:0;"><a name="rfXM-1690643601736"></a>2.设备分配时考虑的因素</h5> 
         <p style="margin-left:0;"><a name="QTLt-1690643649196"></a></p> 
         <p><img alt="" height="230" src="https://i-blog.csdnimg.cn/blog_migrate/df4f33d6d4d60a27acd6e5a2b34bc254.png" width="974"></p> 
         <h5 style="margin-left:0;"><a name="KXzF-1690643601738"></a>1.固有属性</h5> 
         <p style="margin-left:0;"><a name="eAwp-1690643601740"></a>设备的固有属性可分为三种:独占设备、共享设备、虚拟设备。</p> 
         <ol>
          <li><a name="9eHX-1690643601742"></a>独占设备—— 一个时段只能分配给一个进程（如打印机)</li>
          <li><a name="LPZC-1690643601744"></a>共享设备――可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。</li>
          <li><a name="dHJI-1690643601746"></a>虚拟设备――采用SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</li>
         </ol> 
         <h5 style="margin-left:0;"><a name="AIDY-1690643601748"></a>2.分配算法</h5> 
         <p style="margin-left:0;"><a name="yUWS-1690643601750"></a>先来先服务，优先级高者优先，短任务优先…</p> 
         <h5 style="margin-left:0;"><a name="G30t-1690643601752"></a>3.安全性</h5> 
         <p style="margin-left:0;"><a name="qez1-1690643601754"></a>从进程运行的安全性上考虑，设备分配有两种方式:</p> 
         <p style="margin-left:0;"><a name="sQxU-1690643601756"></a><strong>安全分配方式</strong>:为进程<strong>分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。</strong>(eg:考虑进程请求打印机打印输出的例子)</p> 
         <ol>
          <li><a name="YTle-1690643601758"></a>一个时段内每个进程只能使用一个设备</li>
          <li><a name="JM1G-1690643601760"></a>优点:破坏了“请求和保持”条件，不会死锁</li>
          <li><a name="A72L-1690643601762"></a>缺点:对于一个进程来说，CPU和I/o设备只能串行工作</li>
         </ol> 
         <p style="margin-left:0;"><a name="E7ED-1690643601764"></a><strong>不安全分配方式:</strong>进程发出I/o请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/o请求。只有某个l/o请求得不到满足时才将进程阻塞。</p> 
         <ol>
          <li><a name="MLkA-1690643601766"></a>一个进程可以同时使用多个设备</li>
          <li><a name="LJHe-1690643601768"></a>优点:进程的计算任务和I/o任务可以并行处理，使进程迅速推进</li>
          <li><a name="2JDb-1690643601771"></a>缺点:有可能发生死锁(死锁避免、死锁的检测和解除)</li>
         </ol> 
         <h5 style="margin-left:0;"><a name="hI4n-1690643601773"></a>3.静态分配和动态分配</h5> 
         <p style="margin-left:0;"><a name="Vhz6-1690643601775"></a>静态分配:进程运行前为其分配全部所需资源，运行结束后归还资源。破坏了“请求和保持”条件，不会发生死锁</p> 
         <p style="margin-left:0;"><a name="pgrL-1690643601777"></a>动态分配:进程运行过程中动态申请设备资源</p> 
         <h5 style="margin-left:0;"><a name="bLPj-1690643601779"></a>4.设备分配中的数据结构</h5> 
         <p style="margin-left:0;"><a name="SPQv-1690643601781"></a>“设备、控制器、通道”之间的关系:</p> 
         <p style="margin-left:0;"><a name="BQqD-1690644179318"></a></p> 
         <p><img alt="" height="230" src="https://i-blog.csdnimg.cn/blog_migrate/2ac80efb3d316ebfcfbed4d391cfe153.png" width="974"></p> 
         <ol>
          <li><a name="Zd8d-1690643601783"></a>设备控制表（DCT)?<strong>?</strong><strong>系统为每个设备配置一张DCT，用于记录设备情况**控制器控制表(COCT)</strong>😗每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</li>
         </ol> 
         <p style="margin-left:0;"><a name="OMR6-1690644452341"></a></p> 
         <p><img alt="" height="349" src="https://i-blog.csdnimg.cn/blog_migrate/3ab9308dd58ed7d0fac6846bb7702230.png" width="1103"></p> 
         <ol>
          <li><a name="SfYb-1690643601785"></a>通道控制表（CHCT)😗*每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</li>
         </ol> 
         <p style="margin-left:0;"><a name="QUbu-1690644457845"></a></p> 
         <p><img alt="" height="303" src="https://i-blog.csdnimg.cn/blog_migrate/0cd0bb857e172ec21558e073d3501226.png" width="1124"></p> 
         <ol>
          <li><a name="bnlf-1690643601787"></a>系统设备表(SDT):记录了系统中全部设备的情况，每个设备对应一个表目。</li>
         </ol> 
         <p style="margin-left:0;"><a name="d7LV-1690644464372"></a></p> 
         <p><img alt="" height="299" src="https://i-blog.csdnimg.cn/blog_migrate/a3201aa2eda23b7eece92344cac5389b.png" width="1157"></p> 
         <h5 style="margin-left:0;"><a name="EXuD-1690643601789"></a>5.设备分配的步骤</h5> 
         <p style="margin-left:0;"><a name="vkMW-1690643601791"></a>①根据进程请求的物理设备名查找SDT（注:物理设备名是进程请求分配设备时提供的参数)</p> 
         <p style="margin-left:0;"><a name="LNA8-1690643601793"></a>②根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</p> 
         <p style="margin-left:0;"><a name="C23n-1690643601795"></a>③根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p> 
         <p style="margin-left:0;"><a name="5d5c-1690643601797"></a>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p> 
         <p style="margin-left:0;"><a name="fdrN-1690643601799"></a>注∶只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可后动/O设备进行数据传送。</p> 
         <p style="margin-left:0;"><a name="rXT5-1690643601801"></a>缺点:</p> 
         <p style="margin-left:0;"><a name="7SlL-1690643601803"></a>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</p> 
         <p style="margin-left:0;"><a name="NDUM-1690643601805"></a>②若换了一个物理设备，则程序无法运行</p> 
         <p style="margin-left:0;"><a name="zw3S-1690643601807"></a>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</p> 
         <p style="margin-left:0;"><a name="9oyO-1690643601809"></a>改进方法:建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p> 
         <h5 style="margin-left:0;"><a name="e29n-1690643601811"></a>6.设备分配步骤的改进</h5> 
         <p style="margin-left:0;"><a name="JzVh-1690643601813"></a>①根据进程请求的逻辑设备名查找SDT(注:用户编程时提供的逻辑设备名其实就是“设备类型”)</p> 
         <p style="margin-left:0;"><a name="lrl6-1690643601815"></a>②查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT)中新增一个表项。</p> 
         <p style="margin-left:0;"><a name="FUF1-1690643601817"></a>③根据DCT找到cOCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</p> 
         <p style="margin-left:0;"><a name="4muZ-1690643601819"></a>④根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</p> 
         <p style="margin-left:0;"><a name="2nIB-1690643601821"></a>逻辑设备表</p> 
         <h4 style="margin-left:0;"><a name="zh4r-1690556970027"></a>8.缓冲区管理</h4> 
         <h5 style="margin-left:0;"><a name="SJZa-1690644497343"></a>1.知识总览</h5> 
         <p style="margin-left:0;"><a name="T3DL-1690644598025"></a></p> 
         <p><img alt="" height="458" src="https://i-blog.csdnimg.cn/blog_migrate/4ec3134b20bf0cbb87eb75818bbf917a.png" width="1021"></p> 
         <h5 style="margin-left:0;"><a name="5QyV-1690644497345"></a>2.含义和作用</h5> 
         <p style="margin-left:0;"><a name="rjZC-1690644497347"></a>含义</p> 
         <p style="margin-left:0;"><a name="oF3b-1690644497349"></a>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p> 
         <p style="margin-left:0;"><a name="Imfy-1690644497351"></a>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本)</p> 
         <p style="margin-left:0;"><a name="DGUS-1690644497353"></a>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p> 
         <p style="margin-left:0;"><a name="MIdg-1690644497355"></a>作用</p> 
         <p style="margin-left:0;"><a name="m0Fh-1690644592520"></a></p> 
         <p><img alt="" height="607" src="https://i-blog.csdnimg.cn/blog_migrate/24835462d4a991b25dbd976dca7cb45a.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="lsQg-1690644497357"></a>3.单缓冲</h5> 
         <p style="margin-left:0;"><a name="qO3N-1690644497359"></a>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。如图所示</p> 
         <p style="margin-left:0;"><a name="gjJU-1690644497361"></a><strong>注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</strong></p> 
         <p style="margin-left:0;"><a name="aZ7z-1690644575524"></a></p> 
         <p><img alt="" height="489" src="https://i-blog.csdnimg.cn/blog_migrate/d9633cf30bd0981298b9c88002545f90.png" width="1200"></p> 
         <ul>
          <li><a name="afSM-1690644497363"></a>处理一块数据的平均时间</li>
         </ul> 
         <p style="margin-left:0;"><a name="LT88-1690644559514"></a></p> 
         <p><img alt="" height="531" src="https://i-blog.csdnimg.cn/blog_migrate/e314126b33a4de7d7f56f133880a294b.png" width="1200"></p> 
         <h5 style="margin-left:0;"><a name="wJLr-1690644497365"></a>4.双缓冲</h5> 
         <p style="margin-left:0;"><a name="Q0mY-1690644497367"></a>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块)。</p> 
         <ul>
          <li><a name="4B1c-1690644497369"></a>假设T&gt;C+M</li>
         </ul> 
         <p style="margin-left:0;"><a name="KK5h-1690644543491"></a></p> 
         <p><img alt="" height="574" src="https://i-blog.csdnimg.cn/blog_migrate/ce37aead09f251370b2b63cd70656ef9.png" width="1200"></p> 
         <ul>
          <li><a name="XuwI-1690644497371"></a>假设T&lt;C+M</li>
         </ul> 
         <p style="margin-left:0;"><a name="L3lA-1690644527476"></a></p> 
         <p><img alt="" height="504" src="https://i-blog.csdnimg.cn/blog_migrate/95d07bcbb12e15beba2fbd700d8006d9.png" width="1196"></p> 
         <p style="margin-left:0;"><a name="94Cd-1690644497373"></a><strong>结论:采用双缓冲策略，处理一个数据块的平均耗时为Max (T,C+M)。</strong></p> 
         <h5 style="margin-left:0;"><a name="CIOc-1690644497375"></a>5.循环缓冲区</h5> 
         <p style="margin-left:0;"><a name="QUEB-1690644497377"></a>将多个大小相等的缓冲区链接成一个循环队列。</p> 
         <p style="margin-left:0;"><a name="kdRe-1690644497379"></a>注:以下图示中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p> 
         <p style="margin-left:0;"><a name="0okv-1690644517908"></a></p> 
         <p><img alt="" height="433" src="https://i-blog.csdnimg.cn/blog_migrate/60fae098aa2efd0bbccfc7b30916c1f7.png" width="941"></p> 
         <h5 style="margin-left:0;"><a name="Oyl7-1690644497381"></a>6.缓冲池</h5> 
         <p style="margin-left:0;"><a name="poUF-1690644497383"></a>缓冲池由系统中共用的缓冲区组成。</p> 
         <p style="margin-left:0;"><a name="pmDH-1690644497385"></a>这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列(输入队列)、装满输出数据的缓冲队列（输出队列）。</p> 
         <p style="margin-left:0;"><a name="7lL8-1690644497387"></a>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:用于收容输入数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区（sin)、用于收容输出数据的工作缓冲区(hout） 、用于提取输出数据的工作缓冲区(sout)。</p> 
         <p style="margin-left:0;"><a name="zlu3-1690644511941"></a></p> 
         <p style="margin-left:0;"><a name="wKyT-1690644512441"></a></p> 
         <p><img alt="" height="505" src="https://i-blog.csdnimg.cn/blog_migrate/4ad7173bc55da2d2dd4b0a67a6723f05.png" width="1200"></p> 
         <p style="margin-left:0;"><a name="l4vd-1690644512446"></a></p> 
        </div> 
       </div> 
      </article>   
      <img src="https://img-home.csdnimg.cn/images/20211209110851.png" alt="pdf_watermark" width="0" height="0" style="display: none"> 
      <div class="print_watermark"></div> 
      <div class="print_watermark_info"> 
       <p>内容来源：csdn.net</p> 
       <p>作者昵称：用草书谱写兰亭序</p> 
       <p>原文链接：https://blog.csdn.net/qq_62325622/article/details/134852570</p> 
       <p>作者主页：https://blog.csdn.net/qq_62325622</p> 
      </div> 
      <style>
    .print_watermark, .print_watermark_info {
      display: none
    }
    @media print {
      body {
        -webkit-print-color-adjust: exact; /* Chrome, Safari */
        color-adjust: exact; /* Firefox */
        background-image: none !important;
      }
      * {
        -webkit-print-color-adjust: exact;
      }
      .blog-content-box {
        padding: 0;
      }
      .blog-content-box .article-header .article-info-box > div:not(.article-bar-top){
        display: none !important;
      }
      .blog-content-box .article-header .article-info-box  .article-bar-top img{
          display:none
      }
      .blog-content-box .article-header .article-info-box > .article-bar-top .bar-content > *:not(.follow-nickName):not(.time){
          display: none !important;
      }
      .print_watermark {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        z-index: 999;
        background-image: url('https://img-home.csdnimg.cn/images/20211209110851.png');
        background-size: 180px auto;
        background-repeat: repeat;
      }
      .print_watermark_info {
        display: block;
        position: fixed;
        bottom: 16px;
        right: 0;
        z-index: 1000;
        color: #e8e8ed;
        font-size: 12px;
        ocapity: .5
      }
      @page {
        margin: 0 10mm 10mm;
        size: landscape;
      }
      body, article {
        width: 100%;
        margin: 0;
        padding: 0;
      }
      #csdn-toolbar,.main_father > *:not(#mainBox), .csdn-side-toolbar, .main_father aside {
        display: none !important;
      }
      .main_father > #mainBox {
        width: unset
      }
      .main_father > #mainBox > main > *:not(.blog-content-box){
        display: none !important;
      }
    }
  </style> 
     </div> 
     <div class="directory-boxshadow-dialog" style="display:none;"> 
      <div class="directory-boxshadow-dialog-box"> 
      </div> 
      <div class="vip-limited-time-offer-box-new" id="vip-limited-time-offer-box-new"> 
       <img class="limited-img limited-img-new" src="https://csdnimg.cn/release/blogv2/dist/pc/img/vip-limited-close-newWhite.png"> 
       <div class="vip-limited-time-top">
         确定要放弃本次机会？ 
       </div> 
       <span class="vip-limited-time-text">福利倒计时</span> 
       <div class="limited-time-box-new"> 
        <span class="time-hour"></span> 
        <i>:</i> 
        <span class="time-minite"></span> 
        <i>:</i> 
        <span class="time-second"></span> 
       </div> 
       <div class="limited-time-vip-box"> 
        <p> <img class="coupon-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/vip-limited-close-roup.png"> <span class="def">立减 ¥</span> <span class="active limited-num"></span> </p> 
        <span class="">普通VIP年卡可用</span> 
       </div> 
       <a class="limited-time-btn-new" href="https://mall.csdn.net/vip" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.9621&quot;}" data-report-query="spm=1001.2101.3001.9621">立即使用</a> 
      </div> 
     </div> 
     <div class="more-toolbox-new more-toolbar" id="toolBarBox"> 
      <div class="left-toolbox"> 
       <div class="toolbox-left"> 
        <div class="profile-box"> 
         <a class="profile-href" target="_blank" href="https://blog.csdn.net/qq_62325622"><img class="profile-img" src="https://profile-avatar.csdnimg.cn/8844a7fb3f7f4ee39bf6a9f9447a6f1f_qq_62325622.jpg!1"> <span class="profile-name"> 用草书谱写兰亭序 </span> </a> 
        </div> 
        <div class="profile-attend"> 
         <a class="tool-attend tool-bt-button tool-bt-attend" href="javascript:;" data-report-view="{&quot;mod&quot;:&quot;1592215036_002&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4232&quot;,&quot;extend1&quot;:&quot;关注&quot;}">关注</a> 
         <a class="tool-item-follow active-animation" style="display:none;">关注</a> 
        </div> 
       </div> 
       <div class="toolbox-middle"> 
        <ul class="toolbox-list"> 
         <li class="tool-item tool-item-size tool-active is-like" id="is-like" data-type="bottom"> <a class="tool-item-href"> <img style="display:none;" id="is-like-imgactive-animation-like" class="animation-dom active-animation" src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarThumbUpactive.png" alt=""> <img class="isactive" style="display:none" id="is-like-imgactive" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/like-active.png" alt=""> <img class="isdefault" style="display:block" id="is-like-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/like.png" alt=""> <span id="spanCount" class="count "> 400 </span> </a> 
          <div class="tool-hover-tip">
           <span class="text space">点赞</span>
          </div> </li> 
         <li class="tool-item tool-item-size tool-active is-unlike" id="is-unlike"> <a class="tool-item-href"> <img class="isactive" style="margin-right:0px;display:none" id="is-unlike-imgactive" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/unlike-active.png" alt=""> <img class="isdefault" style="margin-right:0px;display:block" id="is-unlike-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/unlike.png" alt=""> <span id="unlikeCount" class="count "></span> </a> 
          <div class="tool-hover-tip">
           <span class="text space">踩</span>
          </div> </li> 
         <li class="tool-item tool-item-size tool-active is-collection "> <a class="tool-item-href" href="javascript:;" data-report-click="{&quot;mod&quot;:&quot;popu_824&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4130&quot;,&quot;ab&quot;:&quot;new&quot;}"> <img style="display:none" id="is-collection-img-collection" class="animation-dom active-animation" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/collect-active.png" alt=""> <img class="isdefault" id="is-collection-img" style="display:block" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/collect.png" alt=""> <img class="isactive" id="is-collection-imgactive" style="display:none" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCollectActive.png" alt=""> <span class="count get-collection " data-num="1492" id="get-collection"> 1492 </span> </a> 
          <div class="tool-hover-tip collect"> 
           <div class="collect-operate-box"> 
            <span class="collect-text" id="is-collection"> 收藏 </span> 
           </div> 
          </div> 
          <div class="tool-active-list"> 
           <div class="text">
             觉得还不错? 
            <span class="collect-text" id="tool-active-list-collection"> 一键收藏 </span> 
            <img id="tool-active-list-close" src="https://csdnimg.cn/release/blogv2/dist/pc/img/collectionCloseWhite.png" alt=""> 
           </div> 
          </div> </li> 
         <li class="tool-item tool-item-size tool-active tool-item-comment"> 
          <div class="guide-rr-first"> 
           <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/guideRedReward01.png" alt=""> 
           <button class="btn-guide-known">知道了</button> 
          </div> <a class="tool-item-href go-side-comment" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7009&quot;}"> <img class="isdefault" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/comment.png" alt=""> <span class="count"> 16 </span> </a> 
          <div class="tool-hover-tip">
           <span class="text space">评论</span>
          </div> </li> 
         <li class="tool-item tool-item-size tool-active tool-QRcode" data-type="article" id="tool-share"> <a class="tool-item-href" href="javascript:;" data-report-view="{&quot;spm&quot;:&quot;3001.4129&quot;,&quot;extra&quot;:{&quot;type&quot;:&quot;blogdetail&quot;}}"> <img class="isdefault" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/share.png" alt=""> <span class="count">分享</span> </a> 
          <div class="QRcode" id="tool-QRcode"> 
           <div class="share-bg-box"> 
            <div class="share-content"> 
             <a id="copyPosterUrl" data-type="link" class="btn-share">复制链接</a> 
            </div> 
            <div class="share-content"> 
             <a class="btn-share" data-type="qq">分享到 QQ</a> 
            </div> 
            <div class="share-content"> 
             <a class="btn-share" data-type="weibo">分享到新浪微博</a> 
            </div> 
            <div class="share-code"> 
             <div class="share-code-box" id="shareCode"></div> 
             <div class="share-code-text"> 
              <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/share/icon-wechat.png" alt="">扫一扫 
             </div> 
            </div> 
           </div> 
          </div> </li> 
         <li class="tool-item tool-item-size tool-active tool-item-reward"> <a class="tool-item-href" href="javascript:;" data-report-click="{&quot;mod&quot;:&quot;popu_830&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4237&quot;,&quot;dest&quot;:&quot;&quot;,&quot;ab&quot;:&quot;new&quot;}"> <img class="isdefault reward-bt" id="rewardBtNew" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/reward.png" alt="打赏"> <span class="count">打赏</span> </a> 
          <div class="tool-hover-tip">
           <span class="text space">打赏</span>
          </div> </li> 
         <li class="tool-item tool-item-size tool-active tool-downloadpdf" id="tool-downloadpdf"> <a class="tool-item-href" data-report-click="{&quot;spm&quot;:&quot;3001.6881&quot;,&quot;extra&quot;:&quot;{\&quot;type\&quot;:\&quot;hide\&quot;}&quot;}" data-report-view="{&quot;spm&quot;:&quot;3001.6881&quot;,&quot;extra&quot;:&quot;{\&quot;type\&quot;:\&quot;hide\&quot;}&quot;}"> <img class="isdefault" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/pdf.png" alt=""> </a> 
          <div class="tool-hover-tip">
           <span class="text">导出PDF</span>
          </div> </li> 
         <li class="tool-item tool-item-size tool-active is-more" id="is-more"> <a class="tool-item-href"> <img class="isdefault" style="margin-right:0px;display:block" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/more.png" alt=""> <span class="count"></span> </a> 
          <div class="more-opt-box"> 
           <div class="mini-box"> 
            <a class="tool-item-href" id="rewardBtNewHide" data-report-click="{&quot;spm&quot;:&quot;3001.4237&quot;,&quot;extra&quot;:&quot;{\&quot;type\&quot;:\&quot;hide\&quot;}&quot;}"> <img class="isdefault reward-bt" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/reward.png" alt="打赏"> <span class="count">打赏</span> </a> 
            <a class="tool-item-href" data-report-click="{&quot;spm&quot;:&quot;3001.6881&quot;,&quot;extra&quot;:&quot;{\&quot;type\&quot;:\&quot;hide\&quot;}&quot;}" data-report-view="{&quot;spm&quot;:&quot;3001.6881&quot;,&quot;extra&quot;:&quot;{\&quot;type\&quot;:\&quot;hide\&quot;}&quot;}"> <img class="isdefault" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/pdf.png" alt=""> <span class="count">导出PDF</span> </a> 
            <a class="tool-item-href" id="toolReportBtnHide"> <img class="isdefault" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/report.png" alt=""> <span class="count">举报</span> </a> 
           </div> 
           <div class="normal-box"> 
            <a class="tool-item-href" id="toolReportBtnHideNormal"> <img class="isdefault" src="https://csdnimg.cn/release/blogv2/dist/pc/img/toolbar/report.png" alt=""> <span class="count">举报</span> </a> 
           </div> 
          </div> </li> 
        </ul> 
       </div> 
       <div class="toolbox-right"> 
        <div class="tool-directory"> 
         <a class="bt-columnlist-show" data-id="12522101" data-free="true" data-description="此专栏是用来操作系统的学习和复习使用的" data-subscribe="false" data-title="操作系统" data-img="https://i-blog.csdnimg.cn/columns/default/20201014180756928.png?x-oss-process=image/resize,m_fixed,h_224,w_224" data-url="https://blog.csdn.net/qq_62325622/category_12522101.html" data-sum="8" data-people="27" data-price="0" data-hotrank="0" data-status="true" data-oldprice="0" data-join="false" data-studyvip="true" data-studysubscribe="false" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.6334&quot;,&quot;extend1&quot;:&quot;专栏目录&quot;}" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.6334&quot;,&quot;extend1&quot;:&quot;专栏目录&quot;}">专栏目录</a> 
        </div> 
       </div> 
      </div> 
     </div>   
     <a id="commentBox" name="commentBox"></a> 
     <div id="pcCommentBox" class="comment-box comment-box-new2 login-comment-box-new" style="display:none"> 
      <div class="has-comment" style="display:block"> 
       <div class="one-line-box"> 
        <div class="has-comment-tit go-side-comment"> 
         <span class="count">16</span>&nbsp;条评论 
        </div> 
        <div class="has-comment-con comment-operate-item"></div> 
        <a class="has-comment-bt-right go-side-comment focus">写评论</a> 
       </div> 
      </div> 
     </div> 
     <div class="first-recommend-box recommend-box recommend-highlight-default"> 
      <div class="recommend-item-box type_blog clearfix" data-url="https://devpress.csdn.net/v1/article/detail/125321624" data-report-view="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6661.1&quot;,&quot;mod&quot;:&quot;popu_871&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~activity-1-125321624-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;1&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~activity&quot;,&quot;dest&quot;:&quot;https://devpress.csdn.net/v1/article/detail/125321624&quot;}"> 
       <div class="content-box"> 
        <div class="content-blog display-flex"> 
         <div class="title-box"> 
          <span class="type"> <img src="https://csdnimg.cn/release/blogv2/dist/components/img/blogType.png" alt=""> <span class="tip">博客</span> </span> 
          <a href="https://devpress.csdn.net/v1/article/detail/125321624" class="tit" target="_blank" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6661.1&quot;,&quot;mod&quot;:&quot;popu_871&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~activity-1-125321624-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;1&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~activity&quot;,&quot;dest&quot;:&quot;https://devpress.csdn.net/v1/article/detail/125321624&quot;}" data-report-query="spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-1-125321624-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-1-125321624-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5"> 
           <div class="left ellipsis-online ellipsis-online-1">
            <em>操作系统</em>期末
            <em>复习</em>知识点总结
           </div> </a> 
         </div> 
         <div class="info-box display-flex"> 
          <div class="info"> 
           <a href="https://blog.csdn.net/weixin_46516647" target="_blank"><span class="blog-title">weixin_46516647的博客</span></a> 
          </div> 
          <div class="info display-flex"> 
           <span class="info-block time">06-16</span> 
           <span class="info-block read"><img class="read-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> 5万+ </span> 
          </div> 
         </div> 
        </div> 
        <div class="desc-box"> 
         <a href="https://devpress.csdn.net/v1/article/detail/125321624" target="_blank" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6661.1&quot;,&quot;mod&quot;:&quot;popu_871&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~activity-1-125321624-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;1&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~activity&quot;,&quot;dest&quot;:&quot;https://devpress.csdn.net/v1/article/detail/125321624&quot;}" data-report-query="spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-1-125321624-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Eactivity-1-125321624-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5"> 
          <div class="desc ellipsis-online ellipsis-online-1">
           1. 
           <em>操作系统</em>的定义OS是一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度，方便用户使用计算机的程序集合。即为用户程序提供服务，是用户与硬件系统之间的接口。2. 
           <em>操作系统</em>的作用OS是计算机系统的核心，负责管理整个计算机系统的软硬件资源，制定各种资源的分配策略，调度系统中运行的用户程序，协调用户对资源的需求，从而使真个计算机系统高效有序的工作3. 
           <em>操作系统</em>的常见的分类①批处理
           <em>操作系统</em>：单道批处理（自动、顺序and单道性），多道批处理（宏观上并行，微观上串行，资源利用率高系统吞吐量大；用户响应时间长
          </div> </a> 
        </div> 
       </div> 
      </div> 
     </div>  
     <div class="second-recommend-box recommend-box recommend-highlight-default"> 
      <div class="recommend-item-box type_blog clearfix" data-url="https://blog.csdn.net/wmsjHW/article/details/131315940" data-report-view="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.1&quot;,&quot;mod&quot;:&quot;popu_387&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-131315940-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;1&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~Rate&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/wmsjHW/article/details/131315940&quot;}"> 
       <div class="content-box"> 
        <div class="content-blog display-flex"> 
         <div class="title-box"> 
          <span class="type"> <img src="https://csdnimg.cn/release/blogv2/dist/components/img/blogType.png" alt=""> <span class="tip">博客</span> </span> 
          <a href="https://blog.csdn.net/wmsjHW/article/details/131315940" class="tit" target="_blank" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.1&quot;,&quot;mod&quot;:&quot;popu_387&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-131315940-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;1&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~Rate&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/wmsjHW/article/details/131315940&quot;}" data-report-query="spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-131315940-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-131315940-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5"> 
           <div class="left ellipsis-online ellipsis-online-1">
            <em>操作系统</em>知识点
            <em>复习</em>
           </div> 
           <div class="tag">
            最新发布
           </div> </a> 
         </div> 
         <div class="info-box display-flex"> 
          <div class="info"> 
           <a href="https://blog.csdn.net/wmsjHW" target="_blank"><span class="blog-title">wmsjHW的博客</span></a> 
          </div> 
          <div class="info display-flex"> 
           <span class="info-block time">06-20</span> 
           <span class="info-block read"><img class="read-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> 1132 </span> 
          </div> 
         </div> 
        </div> 
        <div class="desc-box"> 
         <a href="https://blog.csdn.net/wmsjHW/article/details/131315940" target="_blank" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.1&quot;,&quot;mod&quot;:&quot;popu_387&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-131315940-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;1&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~Rate&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/wmsjHW/article/details/131315940&quot;}" data-report-query="spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-131315940-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-131315940-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5"> 
          <div class="desc ellipsis-online ellipsis-online-1">
           <em>操作系统</em>_期末_知识点_
           <em>复习</em>
          </div> </a> 
        </div> 
       </div> 
      </div> 
     </div> 
     <div class="recommend-box insert-baidu-box  recommend-highlight-default"> 
      <div class="recommend-item-box no-index" style="display:none"></div> 
      <div class="recommend-item-box type_blog clearfix" data-url="https://blog.csdn.net/weixin_45129875/article/details/128313839" data-report-view="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.2&quot;,&quot;mod&quot;:&quot;popu_387&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128313839-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;2&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~Rate&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_45129875/article/details/128313839&quot;}"> 
       <div class="content-box"> 
        <div class="content-blog display-flex"> 
         <div class="title-box"> 
          <span class="type"> <img src="https://csdnimg.cn/release/blogv2/dist/components/img/blogType.png" alt=""> <span class="tip">博客</span> </span> 
          <a href="https://blog.csdn.net/weixin_45129875/article/details/128313839" class="tit" target="_blank" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.2&quot;,&quot;mod&quot;:&quot;popu_387&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128313839-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;2&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~Rate&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_45129875/article/details/128313839&quot;}" data-report-query="spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-128313839-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-128313839-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5"> 
           <div class="left ellipsis-online ellipsis-online-1">
            <em>操作系统</em>知识点个人
            <em>复习</em>
           </div> </a> 
         </div> 
         <div class="info-box display-flex"> 
          <div class="info"> 
           <a href="https://blog.csdn.net/weixin_45129875" target="_blank"><span class="blog-title">weixin_45129875的博客</span></a> 
          </div> 
          <div class="info display-flex"> 
           <span class="info-block time">12-14</span> 
           <span class="info-block read"><img class="read-img" src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> 670 </span> 
          </div> 
         </div> 
        </div> 
        <div class="desc-box"> 
         <a href="https://blog.csdn.net/weixin_45129875/article/details/128313839" target="_blank" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.2&quot;,&quot;mod&quot;:&quot;popu_387&quot;,&quot;extra&quot;:&quot;{\&quot;highlightScore\&quot;:0.0,\&quot;utm_medium\&quot;:\&quot;distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-128313839-blog-134852570.235^v43^pc_blog_bottom_relevance_base5\&quot;,\&quot;dist_request_id\&quot;:\&quot;1745311216912_41671\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1745311216912_41671&quot;,&quot;ab_strategy&quot;:&quot;vipdefault&quot;,&quot;index&quot;:&quot;2&quot;,&quot;strategy&quot;:&quot;2~default~BlogCommendFromBaidu~Rate&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_45129875/article/details/128313839&quot;}" data-report-query="spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-128313839-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-128313839-blog-134852570.235%5Ev43%5Epc_blog_bottom_relevance_base5"> 
          <div class="desc ellipsis-online ellipsis-online-1">
           <em>操作系统</em>总结
          </div> </a> 
        </div> 
       </div> 
      </div> 
     </div> 
     <div class="blog-footer-bottom" style="margin-top:10px;"></div>   
    </main> 
    <aside class="blog_container_aside"> 
     <div id="asideProfile" class="aside-box active"> 
      <div class="profile-intro d-flex"> 
       <div class="avatar-box d-flex justify-content-center flex-column"> 
        <a href="https://blog.csdn.net/qq_62325622" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_379&quot;,&quot;spm&quot;:&quot;3001.4121&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622&quot;,&quot;ab&quot;:&quot;new&quot;}"> <img src="https://profile-avatar.csdnimg.cn/8844a7fb3f7f4ee39bf6a9f9447a6f1f_qq_62325622.jpg!1" class="avatar_pic"> </a> 
       </div> 
       <div class="user-info d-flex flex-column profile-intro-name-box"> 
        <div class="profile-intro-name-boxTop"> 
         <a href="https://blog.csdn.net/qq_62325622" target="_blank" class="" id="uid" title="用草书谱写兰亭序" data-report-click="{&quot;mod&quot;:&quot;popu_379&quot;,&quot;spm&quot;:&quot;3001.4122&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622&quot;,&quot;ab&quot;:&quot;new&quot;}"> <span class="name" username="qq_62325622">用草书谱写兰亭序</span> </a> 
        </div> 
        <div class="profile-intro-name-boxFooter-new"> 
         <p class="profile-intro-name-leve"> <span> 博客等级 </span> <img class="level" src="https://csdnimg.cn/identity/blog5.png"> </p> 
         <span class="profile-intro-name-years" title="已加入 CSDN 4年">码龄4年</span> 
        </div> 
       </div> 
      </div> 
      <div class="profile-intro-rank-information"> 
       <dl> 
        <a href="https://blog.csdn.net/qq_62325622" data-report-click="{&quot;mod&quot;:&quot;1598321000_001&quot;,&quot;spm&quot;:&quot;3001.4310&quot;}" data-report-query="t=1"> 
         <dd>
          <span>52</span>
         </dd> 
         <dt>
          原创
         </dt> </a> 
       </dl> 
       <dl title="1980"> 
        <dd>
         1980
        </dd> 
        <dt>
         点赞
        </dt> 
       </dl> 
       <dl title="5361"> 
        <dd>
         5361
        </dd> 
        <dt>
         收藏
        </dt> 
       </dl> 
       <dl id="fanBox" title="1799"> 
        <dd>
         <span id="fan">1799</span>
        </dd> 
        <dt>
         粉丝
        </dt> 
       </dl> 
      </div> 
      <div class="profile-intro-name-boxOpration"> 
       <div class="opt-letter-watch-box"> 
        <a class="personal-watch bt-button" id="btnAttent">关注</a> 
       </div> 
       <div class="opt-letter-watch-box"> 
        <a rel="noopener" class="bt-button personal-letter" href="https://im.csdn.net/chat/qq_62325622" target="_blank">私信</a> 
       </div> 
      </div> 
     </div> 
     <div class="swiper-slide-box-remuneration"> 
      <a data-report-click="{&quot;spm&quot;:&quot;3001.9728&quot;,&quot;extra&quot;:{&quot;index&quot;:&quot;0&quot;}}" data-report-view="{&quot;spm&quot;:&quot;3001.9728&quot;,&quot;extra&quot;:{&quot;index&quot;:&quot;0&quot;}}" href="https://ai.csdn.net/" target="_blank"> <img src="https://i-operation.csdnimg.cn/images/2dd892a9769b4cce9c086db94eab887f.png" alt=""> </a> 
     </div> 
     <div id="asideHotArticle" class="aside-box"> 
      <h3 class="aside-title">热门文章</h3> 
      <div class="aside-content"> 
       <ul class="hotArticle-list"> 
        <li> <a href="https://blog.csdn.net/qq_62325622/article/details/134804522" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_541&quot;,&quot;spm&quot;:&quot;3001.4139&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522&quot;,&quot;ab&quot;:&quot;new&quot;}"> 史上最全的Logisim运算器实验教程（基于华中科技大学计算机组成原理实验） <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> <span class="read">38125</span> </a> </li> 
        <li> <a href="https://blog.csdn.net/qq_62325622/article/details/134852570" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_541&quot;,&quot;spm&quot;:&quot;3001.4139&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134852570&quot;,&quot;ab&quot;:&quot;new&quot;}"> 史上最全的操作系统复习笔记（基于王道和自己整理） <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> <span class="read">34256</span> </a> </li> 
        <li> <a href="https://blog.csdn.net/qq_62325622/article/details/134782074" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_541&quot;,&quot;spm&quot;:&quot;3001.4139&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134782074&quot;,&quot;ab&quot;:&quot;new&quot;}"> 史上最全的Logisim数据表示实验教程（基于华中科技大学计算机组成原理实验） <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> <span class="read">31563</span> </a> </li> 
        <li> <a href="https://blog.csdn.net/qq_62325622/article/details/134840414" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_541&quot;,&quot;spm&quot;:&quot;3001.4139&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134840414&quot;,&quot;ab&quot;:&quot;new&quot;}"> 史上最全的Logisim存储系统实验教程（基于华中科技大学计算机组成原理实验）内赋源码下载 <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> <span class="read">17314</span> </a> </li> 
        <li> <a href="https://blog.csdn.net/qq_62325622/article/details/135082654" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_541&quot;,&quot;spm&quot;:&quot;3001.4139&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/135082654&quot;,&quot;ab&quot;:&quot;new&quot;}"> MIPS CPU设计（基于华中科技大学计组实验） <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> <span class="read">14303</span> </a> </li> 
       </ul> 
      </div> 
     </div> 
     <div id="asideCategory" class="aside-box flexible-box"> 
      <h3 class="aside-title">分类专栏</h3> 
      <div class="aside-content"> 
       <ul> 
        <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12954781.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12954781.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
          <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756754.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class="title oneline"> 后端 </span> </a> <span class="special-column-num">2篇</span> </li> 
        <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12506829.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12506829.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
          <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756754.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class="title oneline"> java </span> </a> <span class="special-column-num">20篇</span> </li> 
        <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12769426.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12769426.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
          <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/direct/967902a5470c4a89a48b0f6ed8d87b57.jpeg?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class="title oneline"> 软件测试 </span> </a> </li> 
        <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12763139.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12763139.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
          <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/direct/c6cc0ad2383a46dd8376446cbad9f918.jpeg?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class="title oneline"> 设计模式 </span> </a> <span class="special-column-num">1篇</span> </li> 
        <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12522101.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12522101.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
          <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756928.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class="title oneline"> 操作系统 </span> </a> <span class="special-column-num">8篇</span> </li> 
        <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12523470.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12523470.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
          <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756738.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class="title oneline"> Python </span> </a> <span class="special-column-num">4篇</span> </li> 
       </ul> 
      </div> 
      <p class="text-center"> <a class="flexible-btn" data-fbox="aside-archive"><img class="look-more" src="https://csdnimg.cn/release/blogv2/dist/pc/img/arrowDownWhite.png" alt=""></a> </p> 
     </div> 
     <div id="asideNewComments" class="aside-box"> 
      <h3 class="aside-title">最新评论</h3> 
      <div class="aside-content"> 
       <ul class="newcomment-list"> 
        <li> <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/qq_62325622/article/details/134804522#comments_37009974" data-report-click="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_37009974&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_37009974&quot;,&quot;ab&quot;:&quot;new&quot;}">史上最全的Logisim运算器实验教程（基于华中科技大学计算机组成原理实验）</a> <p class="comment ellipsis"> <a href="https://blog.csdn.net/2302_79890751" class="user-name" target="_blank">钟意~: </a> <span class="code-comments">需要代码求</span> </p> </li> 
        <li> <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36984823" data-report-click="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36984823&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36984823&quot;,&quot;ab&quot;:&quot;new&quot;}">史上最全的Logisim运算器实验教程（基于华中科技大学计算机组成原理实验）</a> <p class="comment ellipsis"> <a href="https://blog.csdn.net/2303_79337041" class="user-name" target="_blank">池水青: </a> <span class="code-comments">大佬，知道数字示波器怎么使用嘛</span> </p> </li> 
        <li> <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36931671" data-report-click="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36931671&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36931671&quot;,&quot;ab&quot;:&quot;new&quot;}">史上最全的Logisim运算器实验教程（基于华中科技大学计算机组成原理实验）</a> <p class="comment ellipsis"> <a href="https://blog.csdn.net/2301_80205123" class="user-name" target="_blank">2301_80205123: </a> <span class="code-comments">现在还有吗</span> </p> </li> 
        <li> <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36896613" data-report-click="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36896613&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36896613&quot;,&quot;ab&quot;:&quot;new&quot;}">史上最全的Logisim运算器实验教程（基于华中科技大学计算机组成原理实验）</a> <p class="comment ellipsis"> <a href="https://zhuzhaoyu.blog.csdn.net" class="user-name" target="_blank">阑梦清川: </a> <span class="code-comments">有的，加我主页的qq群，问你发你压缩包</span> </p> </li> 
        <li> <a class="title text-truncate" target="_blank" href="https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36895816" data-report-click="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36895816&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_542&quot;,&quot;spm&quot;:&quot;3001.4231&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/134804522#comments_36895816&quot;,&quot;ab&quot;:&quot;new&quot;}">史上最全的Logisim运算器实验教程（基于华中科技大学计算机组成原理实验）</a> <p class="comment ellipsis"> <a href="https://blog.csdn.net/2401_83434430" class="user-name" target="_blank">2401_83434430: </a> <span class="code-comments">还有吗</span> </p> </li> 
       </ul> 
      </div> 
     </div> 
     <div id="asideHotArticle" class="aside-box"> 
      <h3 class="aside-title">大家在看</h3> 
      <div class="aside-content"> 
       <ul class="hotArticle-list"> 
        <li> <a href="https://blog.csdn.net/weixin_52630341/article/details/147424922" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_52630341/article/details/147424922&quot;,&quot;strategy&quot;:&quot;202_1052723-2729222_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_52630341/article/details/147424922&quot;,&quot;strategy&quot;:&quot;202_1052723-2729222_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}"> Vue3 项目中零成本接入 AI 能力（以图搜图、知识问答、文本匹配)... </a> </li> 
        <li> <a href="https://blog.csdn.net/qq_74196888/article/details/147389084" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_74196888/article/details/147389084&quot;,&quot;strategy&quot;:&quot;202_1052723-2729174_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_74196888/article/details/147389084&quot;,&quot;strategy&quot;:&quot;202_1052723-2729174_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}"> Java基础复习（JavaSE进阶）第八章 多线程 </a> </li> 
        <li> <a href="https://blog.csdn.net/D1557329860/article/details/147387810" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/D1557329860/article/details/147387810&quot;,&quot;strategy&quot;:&quot;202_1052723-2729220_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/D1557329860/article/details/147387810&quot;,&quot;strategy&quot;:&quot;202_1052723-2729220_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}"> 控制系统的结构和关键指标 <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> <span class="read">512</span> </a> </li> 
        <li> <a href="https://blog.csdn.net/sikimayi/article/details/147252717" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/sikimayi/article/details/147252717&quot;,&quot;strategy&quot;:&quot;202_1052723-2729221_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/sikimayi/article/details/147252717&quot;,&quot;strategy&quot;:&quot;202_1052723-2729221_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}"> stm32教程：HC-SR04超声波模块 </a> </li> 
        <li> <a href="https://blog.csdn.net/weixin_43490757/article/details/147407463" target="_blank" data-report-click="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_43490757/article/details/147407463&quot;,&quot;strategy&quot;:&quot;202_1052723-2729224_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;spm&quot;:&quot;3001.10093&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weixin_43490757/article/details/147407463&quot;,&quot;strategy&quot;:&quot;202_1052723-2729224_RCMD&quot;,&quot;ab&quot;:&quot;new&quot;}"> 从零开始，基于Autodl云服务器，通过网页与Qwen2.5-vl-7b-instruct对话 <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/readCountWhite.png" alt=""> <span class="read">393</span> </a> </li> 
       </ul> 
      </div> 
     </div> 
     <div id="asideArchive" class="aside-box" style="display:block!important; width:300px;"> 
      <h3 class="aside-title">最新文章</h3> 
      <div class="aside-content"> 
       <ul class="inf_list clearfix"> 
        <li class="clearfix"> <a href="https://blog.csdn.net/qq_62325622/article/details/147423663" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_382&quot;,&quot;spm&quot;:&quot;3001.4136&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/147423663&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_382&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/147423663&quot;,&quot;ab&quot;:&quot;new&quot;}">Java多线程编程实战：核心概念与最佳实践</a> </li> 
        <li class="clearfix"> <a href="https://blog.csdn.net/qq_62325622/article/details/147423556" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_382&quot;,&quot;spm&quot;:&quot;3001.4136&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/147423556&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_382&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/147423556&quot;,&quot;ab&quot;:&quot;new&quot;}">Java多线程编程最佳实践</a> </li> 
        <li class="clearfix"> <a href="https://blog.csdn.net/qq_62325622/article/details/142187110" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_382&quot;,&quot;spm&quot;:&quot;3001.4136&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/142187110&quot;,&quot;ab&quot;:&quot;new&quot;}" data-report-view="{&quot;mod&quot;:&quot;popu_382&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/article/details/142187110&quot;,&quot;ab&quot;:&quot;new&quot;}">云服务器Jenkins部署Springboot项目以及Vue项目</a> </li> 
       </ul> 
       <div class="archive-bar"></div> 
       <div class="archive-box"> 
        <div class="archive-list-item">
         <a href="https://blog.csdn.net/qq_62325622?type=blog&amp;year=2025&amp;month=04" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_538&quot;,&quot;spm&quot;:&quot;3001.4138&quot;,&quot;ab&quot;:&quot;new&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622?type=blog&amp;year=2025&amp;month=04&quot;}"><span class="year">2025年</span><span class="num">2篇</span></a>
        </div> 
        <div class="archive-list-item">
         <a href="https://blog.csdn.net/qq_62325622?type=blog&amp;year=2024&amp;month=09" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_538&quot;,&quot;spm&quot;:&quot;3001.4138&quot;,&quot;ab&quot;:&quot;new&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622?type=blog&amp;year=2024&amp;month=09&quot;}"><span class="year">2024年</span><span class="num">18篇</span></a>
        </div> 
        <div class="archive-list-item">
         <a href="https://blog.csdn.net/qq_62325622?type=blog&amp;year=2023&amp;month=12" target="_blank" data-report-click="{&quot;mod&quot;:&quot;popu_538&quot;,&quot;spm&quot;:&quot;3001.4138&quot;,&quot;ab&quot;:&quot;new&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622?type=blog&amp;year=2023&amp;month=12&quot;}"><span class="year">2023年</span><span class="num">32篇</span></a>
        </div> 
       </div> 
      </div> 
     </div> 
     <!-- 详情页显示目录 --> 
     <!--文章目录--> 
     <div id="asidedirectory" class="aside-box"> 
      <div class="groupfile" id="directory"> 
       <h3 class="aside-title">目录</h3> 
       <div class="align-items-stretch group_item"> 
        <div class="pos-box"> 
         <div class="scroll-box"> 
          <div class="toc-box"></div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </aside>    
   </div> 
   <div class="recommend-right align-items-stretch clearfix" id="rightAside" data-type="recommend"> 
    <aside class="recommend-right_aside"> 
     <div class="rightside-fixed-hide"> 
     </div> 
     <div id="recommend-right"> 
      <div class="flex-column aside-box groupfile" id="groupfile"> 
       <div class="groupfile-div"> 
        <h3 class="aside-title">目录</h3> 
        <div class="align-items-stretch group_item"> 
         <div class="pos-box"> 
          <div class="scroll-box"> 
           <div class="toc-box"></div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
      <div class="aside-box kind_person d-flex flex-column"> 
       <h3 class="aside-title">分类专栏</h3> 
       <div class="align-items-stretch kindof_item" id="kind_person_column"> 
        <div class="aside-content"> 
         <ul> 
          <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12954781.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12954781.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
            <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756754.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class=""> 后端 </span> </a> <span class="special-column-num">2篇</span> </li> 
          <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12506829.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12506829.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
            <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756754.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class=""> java </span> </a> <span class="special-column-num">20篇</span> </li> 
          <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12769426.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12769426.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
            <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/direct/967902a5470c4a89a48b0f6ed8d87b57.jpeg?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class=""> 软件测试 </span> </a> </li> 
          <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12763139.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12763139.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
            <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/direct/c6cc0ad2383a46dd8376446cbad9f918.jpeg?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class=""> 设计模式 </span> </a> <span class="special-column-num">1篇</span> </li> 
          <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12522101.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12522101.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
            <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756928.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class=""> 操作系统 </span> </a> <span class="special-column-num">8篇</span> </li> 
          <li> <a class="clearfix special-column-name" href="https://blog.csdn.net/qq_62325622/category_12523470.html" data-report-click="{&quot;mod&quot;:&quot;popu_537&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4137&quot;,&quot;strategy&quot;:&quot;pc付费专栏左侧入口&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622/category_12523470.html&quot;,&quot;ab&quot;:&quot;new&quot;}"> 
            <div class="special-column-bar "></div> <img src="https://i-blog.csdnimg.cn/columns/default/20201014180756738.png?x-oss-process=image/resize,m_fixed,h_64,w_64" alt="" onerror="this.src='https://i-blog.csdnimg.cn/columns/default/20201014180756922.png?x-oss-process=image/resize,m_fixed,h_64,w_64'"> <span class=""> Python </span> </a> <span class="special-column-num">4篇</span> </li> 
         </ul> 
        </div> 
       </div> 
      </div> 
     </div> 
    </aside> 
   </div> 
   <div class="recommend-right1  align-items-stretch clearfix" id="rightAsideConcision" data-type="recommend"> 
    <aside class="recommend-right_aside"> 
     <div id="recommend-right-concision"> 
      <div class="flex-column aside-box groupfile" id="groupfileConcision"> 
       <div class="groupfile-div1"> 
        <h3 class="aside-title">目录</h3> 
        <div class="align-items-stretch group_item"> 
         <div class="pos-box"> 
          <div class="scroll-box"> 
           <div class="toc-box"></div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </aside> 
   </div> 
  </div> 
  <div class="mask-dark"></div> 
  <div class="skin-boxshadow"></div> 
  <div class="directory-boxshadow"></div> 
  <div class="comment-side-box-shadow comment-side-tit-close" id="commentSideBoxshadow"> 
   <div class="comment-side-content"> 
    <div class="comment-side-tit"> 
     <div class="comment-side-tit-count">
      评论&nbsp;
      <span class="count">16</span>
     </div> 
     <img class="comment-side-tit-close" src="https://csdnimg.cn/release/blogv2/dist/pc/img/closeBt.png">
    </div> 
    <div id="pcCommentSideBox" class="comment-box comment-box-new2 " style="display:block"> 
     <div class="comment-edit-box d-flex"> 
      <div class="user-img"> 
       <a href="https://blog.csdn.net/2401_84444578" target="_blank"> <img src="https://profile-avatar.csdnimg.cn/07a0cb100298449195b408323e319e9a_2401_84444578.jpg!1"> </a> 
      </div> 
      <form id="commentform"> 
       <textarea class="comment-content" name="comment_content" id="comment_content" placeholder="欢迎高质量的评论，低质的评论会被折叠" maxlength="1000"></textarea> 
       <div class="comment-reward-box" style="background-image: url('https://img-home.csdnimg.cn/images/20230131025301.png');"> 
        <a class="btn-remove-reward"></a> 
        <div class="form-reward-box"> 
         <div class="info">
           成就一亿技术人! 
         </div> 
         <div class="price-info">
           拼手气红包
          <span class="price">6.0元</span> 
         </div> 
        </div> 
       </div> 
       <div class="comment-operate-box"> 
        <div class="comment-operate-l"> 
         <span id="tip_comment" class="tip">还能输入<em>1000</em>个字符</span> 
        </div> 
        <div class="comment-operate-c">
          &nbsp; 
        </div> 
        <div class="comment-operate-r"> 
         <div class="comment-operate-item comment-reward"> 
          <img class="comment-operate-img" data-url="https://csdnimg.cn/release/blogv2/dist/pc/img/" src="https://csdnimg.cn/release/blogv2/dist/pc/img/commentReward.png" alt="红包"> 
          <span class="comment-operate-tip">添加红包</span> 
         </div> 
         <div class="comment-operate-item comment-emoticon"> 
          <img class="comment-operate-img" data-url="https://csdnimg.cn/release/blogv2/dist/pc/img/" src="https://csdnimg.cn/release/blogv2/dist/pc/img/commentEmotionIcon.png" alt="表情包"> 
          <span class="comment-operate-tip">插入表情</span> 
          <div class="comment-emoticon-box comment-operate-isshow"> 
           <div class="comment-emoticon-img-box"></div> 
          </div> 
         </div> 
         <div class="comment-operate-item comment-code"> 
          <img class="comment-operate-img" data-url="https://csdnimg.cn/release/blogv2/dist/pc/img/" src="https://csdnimg.cn/release/blogv2/dist/pc/img/commentCodeIcon.png" alt="表情包"> 
          <span class="comment-operate-tip">代码片</span> 
          <div class="comment-code-box comment-operate-isshow"> 
           <ul id="commentCode"> 
            <li><a data-code="html">HTML/XML</a></li> 
            <li><a data-code="objc">objective-c</a></li> 
            <li><a data-code="ruby">Ruby</a></li> 
            <li><a data-code="php">PHP</a></li> 
            <li><a data-code="csharp">C</a></li> 
            <li><a data-code="cpp">C++</a></li> 
            <li><a data-code="javascript">JavaScript</a></li> 
            <li><a data-code="python">Python</a></li> 
            <li><a data-code="java">Java</a></li> 
            <li><a data-code="css">CSS</a></li> 
            <li><a data-code="sql">SQL</a></li> 
            <li><a data-code="plain">其它</a></li> 
           </ul> 
          </div> 
         </div> 
         <div class="comment-operate-item"> 
          <input type="hidden" id="comment_replyId" name="comment_replyId"> 
          <input type="hidden" id="article_id" name="article_id" value="134852570"> 
          <input type="hidden" id="comment_userId" name="comment_userId" value=""> 
          <input type="hidden" id="commentId" name="commentId" value=""> 
          <a data-report-click="{&quot;mod&quot;:&quot;1582594662_003&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4227&quot;,&quot;ab&quot;:&quot;new&quot;}"> <input type="submit" class="btn-comment btn-comment-input" value="评论"> </a> 
         </div> 
        </div> 
       </div> 
      </form> 
     </div> 
     <div class="comment-list-container"> 
      <div class="comment-list-box comment-operate-item"> 
      </div> 
      <div id="lookGoodComment" class="look-good-comment side-look-comment"> 
       <a class="look-more-comment">查看更多评论<img src="https://csdnimg.cn/release/blogv2/dist/pc/img/commentArrowDownWhite.png" alt=""></a> 
      </div> 
      <div id="lookFlodComment" class="look-flod-comment"> 
       <span class="count"></span>&nbsp;条评论被折叠&nbsp;
       <a class="look-more-flodcomment">查看</a> 
      </div> 
      <div class="opt-box text-center"> 
       <div class="btn btn-sm btn-link-blue" id="btnMoreComment"></div> 
      </div> 
     </div> 
    </div> 
    <div id="pcFlodCommentSideBox" class="pc-flodcomment-sidebox"> 
     <div class="comment-fold-tit">
      <span id="lookUnFlodComment" class="back"><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/commentArrowLeftWhite.png" alt=""></span>被折叠的&nbsp;
      <span class="count"></span>&nbsp;条评论 
      <a href="https://blogdev.blog.csdn.net/article/details/122245662" class="tip" target="_blank">为什么被折叠?</a> 
      <a href="https://bbs.csdn.net/forums/FreeZone" class="park" target="_blank"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/iconPark.png">到【灌水乐园】发言</a> 
     </div> 
     <div class="comment-fold-content"></div> 
     <div id="lookBadComment" class="look-bad-comment side-look-comment"> 
      <a class="look-more-comment">查看更多评论<img src="https://csdnimg.cn/release/blogv2/dist/pc/img/commentArrowDownWhite.png" alt=""></a> 
     </div> 
    </div> 
   </div> 
   <div class="comment-rewarddialog-box"> 
    <div class="form-box"> 
     <div class="title-box">
       添加红包 
      <a class="btn-form-close"></a> 
     </div> 
     <form id="commentRewardForm"> 
      <div class="ipt-box"> 
       <label for="txtName">祝福语</label> 
       <div class="ipt-btn-box"> 
        <input type="text" name="name" id="txtName" autocomplete="off" maxlength="50"> 
        <a class="btn-ipt btn-random"></a> 
       </div> 
       <p class="notice">请填写红包祝福语或标题</p> 
      </div> 
      <div class="ipt-box"> 
       <label for="txtSendAmount">红包数量</label> 
       <div class="ipt-txt-box"> 
        <input type="text" name="sendAmount" maxlength="4" id="txtSendAmount" placeholder="请填写红包数量(最小10个)" autocomplete="off"> 
        <span class="after-txt">个</span> 
       </div> 
       <p class="notice">红包个数最小为10个</p> 
      </div> 
      <div class="ipt-box"> 
       <label for="txtMoney">红包总金额</label> 
       <div class="ipt-txt-box error"> 
        <input type="text" name="money" maxlength="5" id="txtMoney" placeholder="请填写总金额(最低5元)" autocomplete="off"> 
        <span class="after-txt">元</span> 
       </div> 
       <p class="notice">红包金额最低5元</p> 
      </div> 
      <div class="balance-info-box"> 
       <label>余额支付</label> 
       <div class="balance-info">
         当前余额
        <span class="balance">3.43</span>元 
        <a href="https://i.csdn.net/#/wallet/balance/recharge" class="link-charge" target="_blank">前往充值 &gt;</a> 
       </div> 
      </div> 
      <div class="opt-box"> 
       <div class="pay-info">
         需支付：
        <span class="price">10.00</span>元 
       </div> 
       <button type="button" class="ml-auto btn-cancel">取消</button> 
       <button type="button" class="ml8 btn-submit" disabled="true">确定</button> 
      </div> 
     </form> 
    </div> 
   </div> 
   <div class="rr-guide-box"> 
    <div class="rr-first-box"> 
     <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/guideRedReward02.png" alt=""> 
     <button class="btn-guide-known next">下一步</button> 
    </div> 
    <div class="rr-second-box"> 
     <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/guideRedReward03.png" alt=""> 
     <button class="btn-guide-known known">知道了</button> 
    </div> 
   </div> 
  </div> 
  <div class="redEnvolope" id="redEnvolope"> 
   <div class="env-box"> 
    <div class="env-container"> 
     <div class="pre-open" id="preOpen"> 
      <div class="top"> 
       <header> 
        <img class="clearTpaErr" :src="redpacketAuthor.avatar" alt=""> 
        <div class="author">
         成就一亿技术人!
        </div> 
       </header> 
       <div class="bot-icon"></div> 
      </div> 
      <footer> 
       <div class="red-openbtn open-start"></div> 
       <div class="tip">
         领取后你会自动成为博主和红包主的粉丝 
        <a class="rule" target="_blank">规则</a> 
       </div> 
      </footer> 
     </div> 
     <div class="opened" id="opened"> 
      <div class="bot-icon"> 
       <header> 
        <a class="creatorUrl" href="" target="_blank"> <img class="clearTpaErr" src="https://profile-avatar.csdnimg.cn/default.jpg!2" alt=""> </a> 
        <div class="author"> 
         <div class="tt">
          hope_wisdom
         </div> 发出的红包 
        </div> 
       </header> 
      </div> 
      <div class="receive-box"> 
       <header></header> 
       <div class="receive-list"> 
       </div> 
      </div> 
     </div> 
    </div> 
    <div class="close-btn"></div> 
   </div> 
  </div> 
  <div id="rewardNew" class="reward-popupbox-new"> 
   <p class="rewad-title">打赏作者<span class="reward-close"><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/closeBt.png"></span></p> 
   <dl class="profile-box"> 
    <dd> 
     <a href="https://blog.csdn.net/qq_62325622" data-report-click="{&quot;mod&quot;:&quot;popu_379&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_62325622&quot;,&quot;ab&quot;:&quot;new&quot;}"> <img src="https://profile-avatar.csdnimg.cn/8844a7fb3f7f4ee39bf6a9f9447a6f1f_qq_62325622.jpg!1" class="avatar_pic"> </a> 
    </dd> 
    <dt> 
     <p class="blog-name">用草书谱写兰亭序</p> 
     <p class="blog-discript">你的鼓励将是我创作的最大动力</p> 
    </dt> 
   </dl> 
   <div class="reward-box-new"> 
    <div class="reward-content">
     <div class="reward-right"></div>
    </div> 
   </div> 
   <div class="money-box"> 
    <span class="choose-money choosed" data-id="1">¥1</span> 
    <span class="choose-money " data-id="2">¥2</span> 
    <span class="choose-money " data-id="4">¥4</span> 
    <span class="choose-money " data-id="6">¥6</span> 
    <span class="choose-money " data-id="10">¥10</span> 
    <span class="choose-money " data-id="20">¥20</span> 
   </div> 
   <div class="sure-box"> 
    <div class="sure-box-money"> 
     <div class="code-box"> 
      <div class="code-num-box"> 
       <span class="code-name">扫码支付：</span>
       <span class="code-num">¥1</span> 
      </div> 
      <div class="code-img-box"> 
       <div class="renovate"> 
        <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/pay-time-out.png"> 
        <span>获取中</span> 
       </div> 
      </div> 
      <div class="code-pay-box"> 
       <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newWeiXin.png" alt=""> 
       <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newZhiFuBao.png" alt=""> 
       <span>扫码支付</span> 
      </div> 
     </div> 
    </div> 
    <div class="sure-box-blance"> 
     <p class="tip">您的余额不足，请更换扫码支付或<a target="_blank" data-report-click="{&quot;mod&quot;:&quot;1597646289_003&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4302&quot;}" href="https://i.csdn.net/#/wallet/balance/recharge?utm_source=RewardVip" class="go-invest">充值</a></p> 
     <p class="is-have-money"><a class="reward-sure">打赏作者</a></p> 
    </div> 
   </div> 
  </div> 
  <div class="pay-code"> 
   <div class="pay-money">
    实付
    <span class="pay-money-span" data-nowprice="" data-oldprice="">元</span>
   </div> 
   <div class="content-blance">
    <a class="blance-bt" href="javascript:;">使用余额支付</a>
   </div> 
   <div class="content-code"> 
    <div id="payCode" data-id=""> 
     <div class="renovate"> 
      <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/pay-time-out.png"> 
      <span>点击重新获取</span> 
     </div> 
    </div> 
    <div class="pay-style">
     <span><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/weixin.png"></span>
     <span><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/zhifubao.png"></span>
     <span><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/jingdong.png"></span>
     <span class="text">扫码支付</span>
    </div> 
   </div> 
   <div class="bt-close"> 
    <svg t="1567152543821" class="icon" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10924" xmlns:xlink="http://www.w3.org/1999/xlink" width="12" height="12"> 
     <defs> 
      <style type="text/css"></style> 
     </defs> 
     <path d="M512 438.378667L806.506667 143.893333a52.032 52.032 0 1 1 73.6 73.621334L585.621333 512l294.485334 294.485333a52.074667 52.074667 0 0 1-73.6 73.642667L512 585.621333 217.514667 880.128a52.053333 52.053333 0 1 1-73.621334-73.642667L438.378667 512 143.893333 217.514667a52.053333 52.053333 0 1 1 73.621334-73.621334L512 438.378667z" fill="" p-id="10925"></path> 
    </svg> 
   </div> 
   <div class="pay-balance"> 
    <input type="radio" class="pay-code-radio" data-type="details"> 
    <span class="span">钱包余额</span> 
    <span class="balance" style="color:#FC5531;font-size:14px;">0</span> 
    <div class="pay-code-tile"> 
     <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/pay-help.png" alt=""> 
     <div class="pay-code-content"> 
      <div class="span"> 
       <p class="title">抵扣说明：</p> 
       <p> 1.余额是钱包充值的虚拟货币，按照1:1的比例进行支付金额的抵扣。<br> 2.余额无法直接购买下载，可以购买VIP、付费专栏及课程。</p> 
      </div> 
     </div> 
    </div> 
   </div> 
   <a class="pay-balance-con" href="https://i.csdn.net/#/wallet/balance/recharge" target="_blank"><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/recharge.png" alt=""><span>余额充值</span></a> 
  </div> 
  <div style="display:none;"> 
   <img src="" onerror="setTimeout(function(){if(!/(csdn.net|iteye.com|baiducontent.com|googleusercontent.com|360webcache.com|sogoucdn.com|bingj.com|baidu.com)$/.test(window.location.hostname)){var test=&quot;\x68\x74\x74\x70\x73\x3a\x2f\x2f\x77\x77\x77\x2e\x63\x73\x64\x6e\x2e\x6e\x65\x74&quot;}},3000);"> 
  </div> 
  <div class="keyword-dec-box" id="keywordDecBox"></div>  
  <!-- 富文本柱状图  --> 
  <link rel="stylesheet" href="https://csdnimg.cn/release/blog_editor_html/release1.6.12/ckeditor/plugins/chart/chart.css">        
  <link rel="stylesheet" href="https://g.csdnimg.cn/lib/cboxEditor/1.1.6/embed-editor.min.css"> 
  <link rel="stylesheet" href="https://csdnimg.cn/release/blog_editor_html/release1.6.12/ckeditor/plugins/codesnippet/lib/highlight/styles/atom-one-light.css">                  
 </body>
</html>