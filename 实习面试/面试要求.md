【技术】基础知识-八股（原理、系统性、深度、广度、最新技术学习能力）、算法和数据结构、编码能力、设计能力
【算法】重在理解思想，切忌死记硬背;一般都是常见中低难度算法，或者在此基础上稍加演变，难度不会太大。如果很久没有写过算法题，请适度刷题以做准备(刷题网站:https://leetcode-cn.com)。
【经验】项目经验（重难点亮点提前思考下）、业务理解（挑战、难点、优化方案、技术选型有思考）
【基本素质】团队协作、沟通表达、owner意识 、解决问题能力
【高潜素质】聪明、自驱、韧性
注意沟通表达，除被动考察，可以引导面试官聊自己擅长的领域，突出自身优势，面试官也想挖掘你的亮点
【注意⚠️】对ai辅助代码的行为很敏感，面试的时候禁止使用



# 面经重点

## TCP/UDP

|          |    TCP     |   UDP    |
| :------: | :--------: | :------: |
|          |  面向连接  |  无连接  |
|          |  可靠传输  | 尽力而为 |
|          |    有序    |   乱序   |
|          |  拥塞控制  |    无    |
| 首部开销 |     大     |    小    |
|          | 全双工通信 |          |

**全双工与半双工**：

全双工：A给B发消息的同时B也能给A发消息

半双工：只能单向通信

### TCP三次握手：

发出请求SYN——相应请求，发出SYN、ACK——回应ACK

形象：

​	客户：你能听到吗——服务器：能听到，你能听到吗——客户：能听到，开始传送

### 四次挥手：

客户：我说完了——服务器：我收到了，我还没说完——服务器：我说完了——客户：我收到了

## 哈希表



## 进程和线程

进程：程序执行的一次过程——PCB

线程：程序执行的最小单位，CPU调度单位——TCB



**TCP协议如何确保稳定传输**

**介绍一下tcp三次握手，四次挥手**

**排序：快排——口述思路，时间复杂度**

**线程池**

**信号量机制，怎么实现PV操作**

**线程调度算法**

**封装继承多态**

**堆与栈**

**内存swap机制**

**B/B+树**

**说一说OSI七层模型和每层的作用**

**调度算法，抢占式非抢占式时间片轮转的区别**

**加锁有哪几种方法**

**锁，知道的锁和用法**

**进程在内存中的内容，内存地分配**

## 死锁有哪些特征与避免

- 占有等待

- 不可抢占

- 互斥

- 循环等待

- #### 避免：

  - 破坏特征之一

**俩队列实现栈**

**LinkedList和ArrayList区别，优缺点**

**数组的扩容和缩容**

**TCP怎么实现可靠传输的**

**TCP滑动窗口**

**进程通信地方式，以及详细说每一个**

**http和https**

**面向过程和面向对象**

**设计模式，观察者模式**

**虚拟内存和物理内存**

**分段和分页**

**TCP 位于网络层中的哪一层**



# C/C++

```c++
#include <iostream>
using namespace std;

int main(){
    cout<<"hello world";
    cout<<"hello world"<<123<<endl;
    renturn 0;
}
```

#### 1.标准库类型

```c++
字符串
	string s="hello";
动态数组--无法确定大小
    vector<int> v = {1,2,3}
```

##### `std::array`（固定大小数组，C++11）

**特点：**
- 编译时确定大小，无法动态调整，元素连续存储。
- 封装了 C 风格数组，提供安全接口（如 `at()` 边界检查）。
- 无额外内存开销，通常分配在栈上。

**性能：**
- 访问速度快（O(1)），无动态内存分配开销。

**适用场景：**
- 大小固定的数据（如矩阵维度、RGB 颜色值）或对性能要求高的场景。

##### `std::pair`（存储两个值的容器）

**特点：**
- 存储两个异构元素（类型可不同），通过 `first` 和 `second` 访问。
- 常用于函数返回多个值或作为 `std::map` 的节点。

**适用场景：**
- 需要临时组合两个值的场景（如坐标点、键值对）

##### `std::map`（键值对容器）

**特点：**
- 基于红黑树实现，键唯一且自动排序。
- 插入/删除/查找时间复杂度为 O(log n)。
- 支持范围查询和有序遍历。

**适用场景：**
- 需要键值关联且保持有序的场景（如字典、配置项）。

#####  `std::set`（唯一值集合）

**特点：**
- 基于红黑树实现，元素唯一且自动排序。
- 插入/删除/查找时间复杂度为 O(log n)。

**适用场景：**
- 需要去重或有序集合的场景（如黑名单、唯一 ID 存储）。

## 堆栈

### 插入数组

```c++
void insert(int *nums, int size, int num, int index) {
    for(i=size-1;i>index;i--){
        nums[i]=nums[i-1];
    }
    nums[index]=num;
}
```

## 链表

```c++
struct ListNode{
    int value;
    ListNode *next;
    ListNode(int x) : value(x),next(nullptr){}
}
```

```c
typedef struct ListNode{
    int val;
    struct ListNode *next;
}ListNode;

ListNode *newListNode(int val){
    ListNode *node;
    node = (ListNode *)malloc(sizeof(ListNode));
    node->val=val;
    node->next=NULL
    return node;
}
```

